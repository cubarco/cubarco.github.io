<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on /home/cubarco</title><link>https://cubl.in/post/</link><description>Recent content in Posts on /home/cubarco</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Thu, 11 Mar 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://cubl.in/post/index.xml" rel="self" type="application/rss+xml"/><item><title>手冲咖啡初体验</title><link>https://cubl.in/2021/03/pour-over-coffee-self-made-first-experience/</link><pubDate>Thu, 11 Mar 2021 00:00:00 +0000</pubDate><guid>https://cubl.in/2021/03/pour-over-coffee-self-made-first-experience/</guid><description>今天手冲壶和滤杯终于到了。第一次自己做手冲，万万没想到，居然感动到想要重启三年没更的博客来记录一下。
感动现场 技术总结 豆子 云南阿拉比卡，水洗，中深烘焙
就是下面这位： 萃取细节 15克咖啡粉（泰摩磨豆机20格细度），萃取总量200克（闷蒸注水45克，时间15秒；因为第一次冲，闷蒸阶段一开始注水量过大，给的水基本都透过去了）。
其实冲完第一壶，磨好的粉还剩8克，所以又冲了110克，这第二壶的口感就酸多了，不知道为什么，以后慢慢玩。
体验 列举一下喝到咖啡时，脑子蹦出的词：顺滑，醇厚，甜感&amp;hellip; 比之前喝到的咖啡都要舒服得多。至少比今天下午开的中药好喝不少： 手冲装备没到之前，都用家里的意式玩具机做咖啡。玩具机出品的意式，直接喝顶不住，很酸、很苦（听说还有口萃咖啡豆的，虽然感觉是梗，但还是有点厉害&amp;hellip;)。做了各种奶咖，好喝是好喝，却又感觉咖啡味淡了点。
难怪这么多人喜欢自己做手冲，滤杯和手冲壶都不贵，做起来方便，喝起来舒服，完事儿又好清洗，确实是不错的体验。
写完博客时已经过了一个多小时了，哇，还是回味无穷。</description></item><item><title>Writeup: CTFZone 2018 Quals</title><link>https://cubl.in/2018/07/writeup-ctfzone/</link><pubDate>Mon, 23 Jul 2018 00:00:00 +0000</pubDate><guid>https://cubl.in/2018/07/writeup-ctfzone/</guid><description>两道PWN题, 一个easypwn_strings, 一个Mobile Bank.
easypwn_strings 问题 You can try to use very interesting and strange string functions ;) Good luck. nc pwn-03.v7frkwrfyhsjtbpfcppnu.ctfz.one 1234 And yes, there is no binary here
这是一道盲pwn类型的题，名义上没有提供二进制。
nc连上之后回显：
Let&amp;#39;s choose string operation! 1. StrLen 2. SubStrRemove 3. StrRemoveLastSymbols 第一个选项：输入一个字符串，回显字符串长度。
You choise - 1 Use str good choise 123 Result: 3 第二个选项显示未实现。
第三个选项：输入一个字符串，和一个数字，服务端移除末尾指定长度的字符串后打印出来。
You choise - 3 Use str int good choise Set string: 1234567 Set number: 3 Delete 3 ending symbols Result: 1234 思路 既然是无ELF文件的盲pwn，那只能摸着石头过河。做题时有以下几个尝试：</description></item><item><title>如何用 Nginx 搭建简单的 DuckDuckGo 代理站</title><link>https://cubl.in/2016/04/how-to-set-up-a-duckduckgo-proxy-site-with-nginx/</link><pubDate>Sat, 09 Apr 2016 00:00:00 +0000</pubDate><guid>https://cubl.in/2016/04/how-to-set-up-a-duckduckgo-proxy-site-with-nginx/</guid><description>最近感觉手机的网络环境经常变，在寝室 v6， 出门 v4，有的时候会懒得开代理。所以就用 cloudflare+nginx 搞了个简单的 DuckDuckGo 代理站，方便随时掏出手机搜索。没有选择代理 Google 有几点原因，一个是 vps 连 Google 经常让输验证码，再就是 DuckDuckGo 不带 cookie 的搜索结果貌似比 Google 优(?)。
Nginx nginx 的配置文件如下。domain.com 改成具体的域名，/path/to/要改成 duck.domain.com 的证书路径。/etc/letsencrypt/live/images.duck.domain.com/是 Let&amp;rsquo;s encrypt 生成证书的默认目录，稍后会提到。
Gist: cubarco/08e99fbf316a435b7935727810e40458
Cloudflare duck.domain.com 可以用 Cloudflare 做 CDN，然后 crypto 策略选 Full(非strict) 的话在服务器上可以随便给 duck.domain.com 创建个证书用，具体参照1。但是像 images.duck.domain.com 这种三级域名的话，Cloudflare 是没有给 SSL 证书的，所以只好自己在服务器上配，推荐用 Let&amp;rsquo;s encrypt 签证书，方便快捷。
Let&amp;rsquo;s encrypt Let&amp;rsquo;s encrypt 的使用细节我就不赘述了，可以看官方给的 Guide2.
这里需要的三个证书可以用如下命令生成：
./letsencrypt-auto certonly --manual -d images.duck.domain.com \ -d icons.duck.domain.com \ -d ac.</description></item><item><title>利用非标准端口 DNS 服务器避免 DNS 劫持</title><link>https://cubl.in/2016/03/avoid-dns-hijacking-with-non-standard-port-dns/</link><pubDate>Wed, 23 Mar 2016 00:00:00 +0000</pubDate><guid>https://cubl.in/2016/03/avoid-dns-hijacking-with-non-standard-port-dns/</guid><description>GFW的DNS劫持原理: 说起来挺简单,GFW对境外DNS的劫持,是在发现你请求敏感域名的DNS记录时,伪装成你请求的DNS返回一个污染的数据包给你的解析器,但并不会丢弃你向境外DNS的请求,也不会丢弃境外DNS返回的正确解析结果,他只是让错误的数据抢先回来欺骗了你的解析器而已,毕竟他直接从国内给你发污染数据怎么都比国外DNS返回正确数据要快.而解析器在先收到了欺骗数据包之后,就不会再管后面返回的正确数据了,这样你就被 DNS劫持了.1
很久以前我是用这篇 blog1提供的方法，就是用 iptables drop 掉 GFW 的假 DNS 解析包。但是 2015 年 GFW 开始采用随机 IP 污染的方式，这种黑名单的解决方案已经不可用了。后来换了 dnscrypt-proxy，还算是比较好用的。但是最近不明原因，dnscrypt-proxy 在使用一段时间之后老是卡住。尝试解决无果，就想办法找替代的方案。
前几天发现 GFW 没有劫持非标准端口的 DNS 服务器，于是想到了下面两种方法避免劫持。
iptables 将外网网卡(我这是 enp8s0)发出的 dport 是 53 的包 DNAT 给 OpenDNS 443 端口。
iptables -t nat -A OUTPUT -o enp8s0 -p udp --dport 53 \ -j DNAT --to 208.67.222.222:443 dnsmasq 以下是采用 OpenDNS 443 端口的示例配置。
port=53 no-resolv # For IPv6 # server=2620:0:ccc::2#443 server=208.67.222.222#443 listen-address=127.0.0.1 Dnsmasq 的具体使用，可以看 ArchWiki2.</description></item><item><title>Writeup: ZCTF</title><link>https://cubl.in/2016/01/writeup-zctf/</link><pubDate>Sun, 24 Jan 2016 00:00:00 +0000</pubDate><guid>https://cubl.in/2016/01/writeup-zctf/</guid><description>2016 年第一篇 blog!
这次只做出两道 pwn, 好忧伤&amp;hellip;
guess 在最近的 32c3ctf 中出现过一道类似的 readme1. 就是把argv[1]改成目的字符串位置，可以在 libc 打出错误信息的时候，被当作文件名打印出来。
Gist: cubarco/cbbd4ab5462c2f0f287b
note1 这题的 note 是以链表形式储存的，堆溢出（edit 存在溢出漏洞）之后可以覆盖地址更改链表结构。我的 exp 思路就是先把一个 note 指向setvbuf()的 got, 然后用 show 把地址 leak 出来，这样可以 offset 到system(). 然后再将另一个 note 地址改到strcmp()的 got, 通过 edit 把内容改成system()的地址。最后调用strcmp(), title 填/bin/sh就可以了。
Gist: cubarco/30a44a61252f448964c4
note2 这题在赛时没找到漏洞，赛后看了 FlappyPig 的 Writeup2, 只是简单的 fastbin, 感觉好可惜&amp;hellip; 360 安全播报给的代码没缩进根本不能看，自己重新写了个。
Gist: cubarco/9752fbbe78a071b04b37
note3 这题同样是没有在赛时做出来，但是与 note2 相反，这题我是找到了两个可以利用的漏洞的(一个是 integer overflow, 另一个是可以增加第八个 note), 但是不知道如何利用。我在比赛的时候一直想着怎么 fastbin, 因为我觉得 unlink 这么古老的 exp 肯定已经不能用了&amp;hellip; 没想到这题的环境刚好适合 unlink, 有点可惜。赛后看了 FlappyPig 的 Writeup2, 自己重新写了个 exp, 也算是复习一下 unlink.</description></item><item><title>Writeup: 32c3ctf</title><link>https://cubl.in/2015/12/writeup-32c3ctf/</link><pubDate>Wed, 30 Dec 2015 00:00:00 +0000</pubDate><guid>https://cubl.in/2015/12/writeup-32c3ctf/</guid><description>forth forth 直接能跑system1。
S&amp;#34; sh&amp;#34; system gurke pickle 在 unpickle 的时候会执行对象的 __reduce__ 方法2。用 eval 把 __main__.flag.flag 打进 stderr 就行了。
Gist: cubarco/e46eb03e1cd06046d130
teufel 这题的 bin 不大，里面的 gadgets 很少，但是给了 libc. 思路就是先 leak 出保存在栈中的 rbp, 然后 offset 到 system。
这个 offset 要先在本机确定后三位(16 进制), 然后跑个脚本，用 0x1000 的步长去爆破服务器上的 offset. 我的办法是先找__stack_chk_fail, 原因是这个函数不需要参数就能输出。
offset.py Gist: cubarco/569fd814a29d8ef988e1
exp.py Gist: cubarco/569fd814a29d8ef988e1
吐槽 ~~readme 的 flag 居然是文件名&amp;hellip; ~~不过LIBC_FATAL_STDERR_这个环境变量确实是以前没见过的。
update 2016-01-24: 关于 readme 这道题，之前以为 flag 是文件名，做 ZCTF 的 guess 时3，回来看才发现原来是把argv[1]改掉了，蛮有意思。</description></item><item><title>Writeup-Pwnable: unexploitable</title><link>https://cubl.in/2015/12/writeup-pwnable-unexploitable/</link><pubDate>Wed, 23 Dec 2015 00:00:00 +0000</pubDate><guid>https://cubl.in/2015/12/writeup-pwnable-unexploitable/</guid><description>ROP 这题主要就是在 0x400560 藏了一个0F 0A的 opcode, 对应的 x64 指令是syscall, 找到这个就好办了。
然后构造 ROP, 一开始找不到控制 rax 的 gadgets, 搜了一下发现可以利用read()的返回值。具体的构造就是时间问题了，x64 的 ROP 可以看这篇文章1。
exp-rop.py Gist: cubarco/23b04edc7e79b1c71547
SROP 结果 flag 里提到 SROP 的解法，我就又写了个 SROP. 简单的 SROP 介绍可以看这篇文章2。
exp-srop.py Gist: cubarco/23b04edc7e79b1c71547
一步一步学ROP之linux_x64篇&amp;#160;&amp;#x21a9;&amp;#xfe0e;
Sigreturn Oriented Programming (SROP) Attack攻击原理&amp;#160;&amp;#x21a9;&amp;#xfe0e;</description></item><item><title>Writeup-Pwnable: syscall</title><link>https://cubl.in/2015/12/writeup-pwnable-syscall/</link><pubDate>Wed, 16 Dec 2015 00:00:00 +0000</pubDate><guid>https://cubl.in/2015/12/writeup-pwnable-syscall/</guid><description>// adding a new system call : sys_upper #include &amp;lt;linux/module.h&amp;gt;#include &amp;lt;linux/kernel.h&amp;gt;#include &amp;lt;linux/slab.h&amp;gt;#include &amp;lt;linux/vmalloc.h&amp;gt;#include &amp;lt;linux/mm.h&amp;gt;#include &amp;lt;asm/unistd.h&amp;gt;#include &amp;lt;asm/page.h&amp;gt;#include &amp;lt;linux/syscalls.h&amp;gt; #define SYS_CALL_TABLE 0x8000e348 // manually configure this address!! #define NR_SYS_UNUSED 223 //Pointers to re-mapped writable pages unsigned int** sct; asmlinkage long sys_upper(char *in, char* out){ int len = strlen(in); int i; for(i=0; i&amp;lt;len; i++){ if(in[i]&amp;gt;=0x61 &amp;amp;&amp;amp; in[i]&amp;lt;=0x7a){ out[i] = in[i] - 0x20; } else{ out[i] = in[i]; } } return 0; } static int __init initmodule(void ){ sct = (unsigned int**)SYS_CALL_TABLE; sct[NR_SYS_UNUSED] = sys_upper; printk(&amp;#34;sys_upper(number : 223) is added\n&amp;#34;); return 0; } static void __exit exitmodule(void ){ return; } module_init( initmodule ); module_exit( exitmodule ); 这题就是提供了一个可以write-anything-anywhere的系统调用(也不算anything，有点限制)，系统调用的地址存在0x8000e348+223 = 0x8000e6c4, flag在/root/flag.</description></item><item><title>Writeup-Pwnable: tiny &amp; tiny_easy</title><link>https://cubl.in/2015/12/writeup-pwnable-tiny-and-tiny-easy/</link><pubDate>Fri, 11 Dec 2015 00:00:00 +0000</pubDate><guid>https://cubl.in/2015/12/writeup-pwnable-tiny-and-tiny-easy/</guid><description>tiny_easy 1. Brute force 这题的 bin 拿到之后开 gdb 看了一下 mapping, 发现 stack 是可执行的(如果 ELF 没有 GNU_STACK 这个 header, 则默认 stack 可执行1)。所以思路很明显了。
看一下反汇编:
8048054: 58 pop %eax 8048055: 5a pop %edx 8048056: 8b12 mov (%edx),%edx 8048058: ffd2 call *%edx 然后用 gdb 断在 entry point, 观察一下栈:
$ gdb tiny_easy (gdb) b *0x8048054 Breakpoint 1 at 0x8048054 (gdb) r Starting program: /home/tiny_easy/tiny_easy Breakpoint 1, 0x08048054 in ?? () (gdb) x/32wx $esp 0xffd82d70: 0x00000001 0xffd84df5 0x00000000 0xffd84e0f 0xffd82d80: 0xffd84e1f 0xffd84e33 0xffd84e54 0xffd84e68 0xffd82d90: 0xffd84e77 0xffd84e83 0xffd84ed0 0xffd84ee9 0xffd82da0: 0xffd84ef8 0xffd84f0c 0xffd84f1d 0xffd84f63 0xffd82db0: 0xffd84f6c 0xffd84f81 0xffd84f89 0xffd84f99 0xffd82dc0: 0xffd84fab 0x00000000 0x00000020 0xf776bb50 0xffd82dd0: 0x00000021 0xf776b000 0x00000010 0x0fabfbff 0xffd82de0: 0x00000006 0x00001000 0x00000011 0x00000064 发现 $esp 位置是命令行参数的个数(即 argc)，后面借着的都是 argv[i], 以 NULL 结尾，再之后都是环境变量(即 envp)。</description></item><item><title>Writeup-Seccon CTF: FSB:TreeWalker</title><link>https://cubl.in/2015/12/seccon-ctf-writeup-fsb-treewalker/</link><pubDate>Mon, 07 Dec 2015 00:00:00 +0000</pubDate><guid>https://cubl.in/2015/12/seccon-ctf-writeup-fsb-treewalker/</guid><description>printf() 因为这题直接把 FSB 写在题名里，我一拿到题就直接跑去找能利用 FSB 的点了。
利用点在这里：
400881: 0f 1f 80 00 00 00 00 nopl 0x0(%rax) 400888: 4c 8b 05 f9 09 20 00 mov 0x2009f9(%rip),%r8 # 601288 &amp;lt;stdin@@GLIBC_2.2.5&amp;gt; 40088f: 48 8d 7c 24 50 lea 0x50(%rsp),%rdi 400894: ba 01 00 00 00 mov $0x1,%edx 400899: be 00 10 00 00 mov $0x1000,%esi 40089e: e8 fd fe ff ff callq 4007a0 &amp;lt;__fread_chk@plt&amp;gt; 4008a3: 48 39 44 24 08 cmp %rax,0x8(%rsp) 4008a8: 0f 85 81 00 00 00 jne 40092f &amp;lt;main+0x14f&amp;gt; 4008ae: 48 8d 74 24 50 lea 0x50(%rsp),%rsi 4008b3: bf 01 00 00 00 mov $0x1,%edi 4008b8: 31 c0 xor %eax,%eax 4008ba: e8 d1 fe ff ff callq 400790 &amp;lt;__printf_chk@plt&amp;gt; 4008bf: 48 8b 0d c2 09 20 00 mov 0x2009c2(%rip),%rcx # 601288 &amp;lt;stdin@@GLIBC_2.</description></item><item><title>Writeup-9447 CTF: calcpop-reloaded</title><link>https://cubl.in/2015/12/9477-calcpop-reloaded-writeup/</link><pubDate>Fri, 04 Dec 2015 00:00:00 +0000</pubDate><guid>https://cubl.in/2015/12/9477-calcpop-reloaded-writeup/</guid><description>从这一题开始，9447 加上了 POW, 其实只要爆破就可以，这里就不放脚本了。（关于 POW, 有个叫 hashcash 的东西，挺有意思的）
这道题我没有在比赛期间做出来。当时完全没有逆向 load address 未知的二进制的经验，什么都干不了。后来简单看了别人的 writeup，在只知道逆向方法的情况下重新做出了这题。前后大概还是花了七八小时（我好渣&amp;hellip;），硬着头皮写篇 writeup 记录一下。
Load Address 找 load address 的过程大概是先用 radare 打开，然后翻反汇编代码，可以找到mov eax, 0x1007a7这类代码，大概可以猜出 load address 在 0x100000.
用 IDA 打开，填好 load offset, 开始调试。可以猜出 main 函数(?)的位置大概在 0x1008bc.
Overflow 接下来找溢出点。可以看到 0x001008EE 处调用了输入函数，分配栈空间是 0x98, 但是传递了一个大概是 size 的参数，值为 0x100. 存在溢出。
这题和 calcpop 有一点不同的是，calcpop 中输入 exit 会直接退出 main 函数，这题输入 exit 会调用shutdown()之类的函数，没细看，效果就是不会再有输出了。这道题退出 main 函数的方法是，正确输入，让计算结果为 201527, 程序会输出彩蛋信息，然后退出 main 函数。
接下来就是怎么溢出了，先看 main 函数入口和出口处的栈变化：
; entry: lea ecx, [esp-4] and esp, 0FFFFFFF0h push dword ptr [ecx-4] push ebp mov ebp, esp push edi push esi push ebx push ecx ; exit: lea esp, [ebp-10h] xor eax, eax pop ecx pop ebx pop esi pop edi pop ebp lea esp, [ecx-4] retn 溢出到保存 ecx 的位置，使 ecx - 4 指向存有 shellcode 地址的栈位置，然后 ret 就能跳转到 shellcode.</description></item><item><title>Writeup-9447 CTF: calcpop</title><link>https://cubl.in/2015/11/9477-calcpop-writeup/</link><pubDate>Mon, 30 Nov 2015 00:00:00 +0000</pubDate><guid>https://cubl.in/2015/11/9477-calcpop-writeup/</guid><description>先看反汇编代码：
... 8048460: 55 push %ebp 8048461: 89 e5 mov %esp,%ebp 8048463: 57 push %edi 8048464: 56 push %esi 8048465: be 00 01 00 00 mov $0x100,%esi 804846a: 53 push %ebx 804846b: 83 e4 f0 and $0xfffffff0,%esp 804846e: 81 ec 90 00 00 00 sub $0x90,%esp 8048474: a1 60 a0 04 08 mov 0x804a060,%eax 8048479: c7 44 24 0c 00 00 00 movl $0x0,0xc(%esp) 8048480: 00 8048481: 8d 5c 24 10 lea 0x10(%esp),%ebx 8048485: c7 44 24 08 02 00 00 movl $0x2,0x8(%esp) 804848c: 00 804848d: 89 df mov %ebx,%edi 804848f: c7 44 24 04 00 00 00 movl $0x0,0x4(%esp) 8048496: 00 8048497: 89 04 24 mov %eax,(%esp) 804849a: e8 a1 ff ff ff call 8048440 &amp;lt;setvbuf@plt&amp;gt; 804849f: c7 04 24 10 88 04 08 movl $0x8048810,(%esp) 80484a6: e8 55 ff ff ff call 8048400 &amp;lt;puts@plt&amp;gt; 80484ab: eb 29 jmp 80484d6 &amp;lt;main+0x76&amp;gt; 80484ad: 8d 76 00 lea 0x0(%esi),%esi 80484b0: a1 40 a0 04 08 mov 0x804a040,%eax 80484b5: 89 04 24 mov %eax,(%esp) 80484b8: e8 33 ff ff ff call 80483f0 &amp;lt;_IO_getc@plt&amp;gt; 80484bd: 85 c0 test %eax,%eax 80484bf: 0f 88 e3 00 00 00 js 80485a8 &amp;lt;main+0x148&amp;gt; 80484c5: 88 07 mov %al,(%edi) 80484c7: 83 ee 01 sub $0x1,%esi 80484ca: 83 c7 01 add $0x1,%edi 80484cd: 83 f8 0a cmp $0xa,%eax 80484d0: 0f 84 ca 00 00 00 je 80485a0 &amp;lt;main+0x140&amp;gt; 80484d6: 83 fe 01 cmp $0x1,%esi 80484d9: 77 d5 ja 80484b0 &amp;lt;main+0x50&amp;gt; 80484db: 85 f6 test %esi,%esi 80484dd: 0f 85 bd 00 00 00 jne 80485a0 &amp;lt;main+0x140&amp;gt; .</description></item><item><title>一个解决 Linux 版 Dota 2 中 CJK 字符显示成方块的 Workaround</title><link>https://cubl.in/2015/05/dota2-blocky-cjk-fonts-workaround/</link><pubDate>Thu, 14 May 2015 00:00:00 +0000</pubDate><guid>https://cubl.in/2015/05/dota2-blocky-cjk-fonts-workaround/</guid><description>不知道从什么时候开始，Linux 版本的 Dota 2 中载入界面的 tips sentences 和 player name 中的中文会显示成方框，详见 issue-1688。V社基本没搭理这个 bug，只好自己动手修。
猜想是游戏内直接使用了某个字体，或者该字体不存在时调用了默认字体，但是他们不支持 CJK 字符，所以显示成方块。因为 SteamFonts 给的全是Arial字体，我猜 Dota 2 那些文本使用的字体可能是Arial，开FC_DEBUG跑了一遍发现猜的没错。那么我们要做的就是用fontconfig把Arial替换成支持中文的字体。
解决办法 替换Arial的fontconfig配置是:
&amp;lt;match target=&amp;#34;pattern&amp;#34;&amp;gt; &amp;lt;test qual=&amp;#34;any&amp;#34; name=&amp;#34;family&amp;#34;&amp;gt; &amp;lt;string&amp;gt;Arial&amp;lt;/string&amp;gt; &amp;lt;/test&amp;gt; &amp;lt;edit name=&amp;#34;family&amp;#34; mode=&amp;#34;assign&amp;#34; binding=&amp;#34;same&amp;#34;&amp;gt; &amp;lt;string&amp;gt;Noto Sans S Chinese&amp;lt;/string&amp;gt; &amp;lt;/edit&amp;gt; &amp;lt;/match&amp;gt; 我用的是Noto Sans S Chinese，如果用文泉驿正黑就改成WenQuanYi Zen Hei。
怎么使这个配置生效？有两个方法。
环境变量 FONTCONFIG_FILE 这个方法需要一个为 Dota 2 单独准备的fontconfig_file，姑且命名为dota2-fontconfig.conf。
文件内容如下:
&amp;lt;?xml version=&amp;#34;1.0&amp;#34;?&amp;gt; &amp;lt;!DOCTYPE fontconfig SYSTEM &amp;#34;fonts.dtd&amp;#34;&amp;gt; &amp;lt;fontconfig&amp;gt; &amp;lt;include ignore_missing=&amp;#34;no&amp;#34;&amp;gt;fonts.conf&amp;lt;/include&amp;gt; &amp;lt;match target=&amp;#34;pattern&amp;#34;&amp;gt; &amp;lt;test qual=&amp;#34;any&amp;#34; name=&amp;#34;family&amp;#34;&amp;gt; &amp;lt;string&amp;gt;Arial&amp;lt;/string&amp;gt; &amp;lt;/test&amp;gt; &amp;lt;edit name=&amp;#34;family&amp;#34; mode=&amp;#34;assign&amp;#34; binding=&amp;#34;same&amp;#34;&amp;gt; &amp;lt;string&amp;gt;Noto Sans S Chinese&amp;lt;/string&amp;gt; &amp;lt;/edit&amp;gt; &amp;lt;/match&amp;gt; &amp;lt;/fontconfig&amp;gt; 然后用FONTCONFIG_FILE环境变量来传递。但是使用这个环境变量之后，fontconfig不会再加载/etc/fonts/fonts.</description></item><item><title>C Programming Tricks</title><link>https://cubl.in/2015/05/c-programming-tricks/</link><pubDate>Sat, 02 May 2015 00:00:00 +0000</pubDate><guid>https://cubl.in/2015/05/c-programming-tricks/</guid><description>这个 Note 用来记录各处收集的 C 编程 tricks. 看到有意思的就会摘一下，来源各异。
Anonymous arrays C99 offers some really cool stuff using anonymous arrays:
Removing pointless variables int yes=1; setsockopt(yourSocket, SOL_SOCKET, SO_REUSEADDR, &amp;amp;yes, sizeof(int)); /* becomes: */ setsockopt(yourSocket, SOL_SOCKET, SO_REUSEADDR, (int[]){1}, sizeof(int)); Passing a Variable Amount of Arguments Void func(type* values) { while(*values) { x = *values++; /* do whatever with x */ } } func((type[]){val1,val2,val3,val4,0}); Static linked lists int main() { struct llist { int a; struct llist* next;}; #define cons(x,y) (struct llist[]){ {x,y} } struct llist *list=cons(1, cons(2, cons(3, cons(4, NULL)))); struct llist *p = list; while(p !</description></item><item><title>解决用 ldconfig 指定 libgl 库时 Steam 的异常</title><link>https://cubl.in/2015/01/ldconfig-and-steam-workaround/</link><pubDate>Wed, 28 Jan 2015 00:00:00 +0000</pubDate><guid>https://cubl.in/2015/01/ldconfig-and-steam-workaround/</guid><description>刚考完试，有点无聊，开 Steam 准备玩点游戏，结果发现之前的一个脚本不能用了。我的机器的情况是 Intel 集显 + NVIDIA 独显。两个显卡的切换一直是件很蛋疼的事情，optirun什么的性能实在太差，如果一直独显直出，耗电也是个大问题。这个学期初和 @hyrathb juju 一起研究了一下，用 ldconfig 尽可能减少切换显卡带来的麻烦(就是先关X, 然后跑个脚本开独显直出的X, 如果需要这个解决方案我可以单独po文).
Steam 的坑 Steam 为了Need to add /usr/lib32 to the library path to pick up libvdpau_nvidia.so on Ubuntu 12.04把/usr/lib32加进了LD_LIBRARY_PATH变量，结果虽然在 ldconfig 中本来是 NVIDIA 的 libgl 库优先，但是/usr/lib32里面默认 mesa 的 libgl 库的链接却被优先加载了。导致 Steam 启动时会报Not direct rendering之类的错误。
之前的解决办法 这个学期初是顺便解决了这个问题的，当时就是把 steam.sh 里面如下这行注释掉。
export LD_LIBRARY_PATH=&amp;#34;$LD_LIBRARY_PATH:/usr/lib32&amp;#34; 但是 Steam 会在启动时检查文件完整性，第一次检查是检查大小，所以把文件删掉一个字节就好了。不过要在启动 Steam 后换回原文件，因为 Steam 会第二次检查文件完整性，这次大概是检查哈希值。我是写了个脚本，准备两个文件，原文件和修改后的文件，cp 两次。不过最近升级后，第一次检查的好像也是哈希值了。检查的那些步骤估计都是写进二进制的，想绕过也比较麻烦，这脚本就没救了。
新发现 这次仔细读了一下 steam.sh, 这一块代码还是可以好好利用一下的:
# and launch steam STEAM_DEBUGGER=$DEBUGGER unset DEBUGGER # Don&amp;#39;t use debugger if Steam launches itself recursively if [ &amp;#34;$STEAM_DEBUGGER&amp;#34; == &amp;#34;gdb&amp;#34; ] || [ &amp;#34;$STEAM_DEBUGGER&amp;#34; == &amp;#34;cgdb&amp;#34; ]; then # Set the LD_PRELOAD varname in the debugger, and unset the global version.</description></item><item><title>在社交平台上发布匹配一定规则的 Github commit message</title><link>https://cubl.in/2015/01/post-github-commits-to-social-platforms/</link><pubDate>Thu, 15 Jan 2015 00:00:00 +0000</pubDate><guid>https://cubl.in/2015/01/post-github-commits-to-social-platforms/</guid><description>之前看到了 @fqj1994 juju 的这篇 blog: 用 Google App Script 實現博客更新時自動在社交網絡上發狀態分享, 也感觉自己的 blog 根本没人访问，需要一个类似的东西。因为我的 blog 是用的 jekyll, 挂在 Github 上的，Github 又提供了一个叫 Webhook 的东西，就准备自己实现一种更加优雅的方式。
项目放在 Github 上，遵循 GPLv2 协议。整个流程很简单，就是接受 Webhook 发来的 json, 然后从中提取 commits message, 用一定的正则表达式取出标题，之后再发往各个社交平台。
昨天实现了 twitter 的部分(twitter 可以拿到不会过期的 access token)，看了下 OAuth 感觉要维护那些 token 的状态好麻烦，懒得弄&amp;hellip; 我正在用的主要就是 twitter, Google+, 和 Facebook. Google+ 据说没给发 post 的 api, 所以作罢。接下来尽可能支持 Facebook.
如果腳本正常的話，理論上這則文章會很快被發佈到我常用的社交網絡。
嗯，就是这样。
Update 2015-01-15: 这个 blog 发出去之后发现 log 报错了(UnicodeEncodeError)，但是没时间修了(出去玩了)。晚上回来处理完各种事情之后才开始修。发现是 urllib.urlencode() 不支持 unicode, fix 已经推到 Github 上了&amp;hellip; 感觉 python 还是学的不好啊。其实我一开始学 python 就是随手写个后台，没准备深入。现在又发觉 python 挺好用的，但是不知道怎么深入，有心无力的感觉哎。</description></item><item><title>Vim 删除成对的字符</title><link>https://cubl.in/2015/01/vimscript-delpair/</link><pubDate>Sun, 11 Jan 2015 00:00:00 +0000</pubDate><guid>https://cubl.in/2015/01/vimscript-delpair/</guid><description>今天为了偷懒又往 .vimrc 里面写了点东西，作用是在删除类似于()这种成对出现的字符对的前一个字符时同时删除后面那个&amp;hellip;
下面是具体内容:
inoremap &amp;lt;BS&amp;gt; &amp;lt;c-r&amp;gt;=DelPair()&amp;lt;CR&amp;gt;function DelPair() let currentline = getline(&amp;#39;.&amp;#39;) let prechar = currentline[col(&amp;#39;.&amp;#39;) - 2] let fochar = currentline[col(&amp;#39;.&amp;#39;) - 1] if (prechar == &amp;#39;(&amp;#39; &amp;amp;&amp;amp; fochar == &amp;#39;)&amp;#39;) \ || (prechar == &amp;#39;[&amp;#39; &amp;amp;&amp;amp; fochar == &amp;#39;]&amp;#39;) \ || (prechar == &amp;#39;&amp;lt;&amp;#39; &amp;amp;&amp;amp; fochar == &amp;#39;&amp;gt;&amp;#39;) \ || (prechar == &amp;#39;{&amp;#39; &amp;amp;&amp;amp; fochar == &amp;#39;}&amp;#39;) \ || (prechar == &amp;#39;&amp;#34;&amp;#39; &amp;amp;&amp;amp; fochar == &amp;#39;&amp;#34;&amp;#39;) \ || (prechar == &amp;#34;&amp;#39;&amp;#34; &amp;amp;&amp;amp; fochar == &amp;#34;&amp;#39;&amp;#34;) return &amp;#34;\&amp;lt;BS&amp;gt;\&amp;lt;Delete&amp;gt;&amp;#34; else return &amp;#34;\&amp;lt;BS&amp;gt;&amp;#34; endifendf</description></item><item><title>vpn-udp-libev 开发总结</title><link>https://cubl.in/2015/01/vpn-udp-libev-development-notes/</link><pubDate>Fri, 09 Jan 2015 00:00:00 +0000</pubDate><guid>https://cubl.in/2015/01/vpn-udp-libev-development-notes/</guid><description>最近又在看 UNIX 网络编程那本书，写了个 vpn 练手，代码和简单的介绍在 Github 上(好像效率还不错的样子)。这里照例做一下总结，便于以后查阅。
关于recvfrom() /* recvfrom() 的声明 */ ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen); 这个函数比较诡异的是它的最后一个参数addrlen.
If src_addr is not NULL, and the underlying protocol provides the source address of the message, that source address is placed in the buffer pointed to by src_addr. In this case, addrlen is a value-result argument. Before the call, it should be initialized to the size of the buffer associated with src_addr.</description></item><item><title>对 btrfs 的吐槽</title><link>https://cubl.in/2015/01/btrfs-sucks/</link><pubDate>Fri, 02 Jan 2015 00:00:00 +0000</pubDate><guid>https://cubl.in/2015/01/btrfs-sucks/</guid><description>刚把本来给/home和/var用的 btrfs 换回 ext4，po 一发记(tu)录(cao)一下。
一开始换 btrfs 呢，是感觉这个文件系统各种功能、各种酷炫啊，比如subvolume, snapshot什么的。我主要看中的其实是他的透明压缩，不仅节省硬盘空间，还能提高io的速率，这对我 5400转的 500G 硬盘还是有点作用的。不过当时年少不懂事，不知道有C这个文件属性，直接在/etc/fstab里用了全局压缩选项，结果导致虚拟机这种从单文件随机读取数据的场景速度慢到可怕。
有一个日常使用经常遇到的问题，不知道是不是和这个压缩的功能有关。跨文件系统(具体好像是btrfs&amp;lt;-&amp;gt;{fat32,ntfs})cp或者mv的时候，非常有可能会在读写进行到最后的时候 hang 住，怎么kill都终止不了 io 进程。这个时候如果ps看一下，会发现 io 进程陷入了disk_sleep的状态。这时候只好直接拔 USB 储存才行。
还有就是大家都在说的 btrfs 会丢失文件的问题。虽然我只遇到过一次，时间是在刚换 btrfs 之后没几天，有一个目录里面的有些文件莫名其妙就不见了，我当时很肯定是没有动这个目录的文件的，所以这件事就让我对 btrfs 的印象变得不是那么好了。
subvolume, snapshot虽然很酷，但是平时基本也没有不会用到太多。
subvolume可以实现一个分区挂载到多个目录，这样就省去了分区的麻烦。但是硬盘里面的东西多了以后，挂载一个subvolume的速度会变得非常慢。在我换回 ext4 之前，挂载一个subvolume的时间平均是 5s, 一次开机就让挂载卡去了 15s, 实在是非常不划算。而且这也不是没有替代方案。比如我现在就是把/var和/home放在一个分区，开机后挂载整个分区，然后用bind的方式挂载到根目录的具体位置上。
至于snapshot，用到它的就是我每两天一次的全盘备份和 docker 了。这还确实有点用处，不过用了半年，需要用到备份的时间也就一两次，docker 有没有 btrfs 其实也没什么区别。
所以呢，总的来说， btrfs 的问题还是有点多，一些有意思的功能日常也起不到必不可少的作用。想入 btrfs 坑的还是再观望一段时间吧，已经入 btrfs 坑的话我只能祝你好运了。</description></item><item><title>Paf 开发总结</title><link>https://cubl.in/2014/12/paf-develop-notes/</link><pubDate>Wed, 31 Dec 2014 00:00:00 +0000</pubDate><guid>https://cubl.in/2014/12/paf-develop-notes/</guid><description>Paf (Pipe as file) 并不是什么大项目，只是一时兴起为满足自己奇怪需求而开发的小工具。具体的介绍都摆在 Github 上了，这里就不赘述了。只是对开发过程中遇到的一些问题和技巧做一下总结。
EOF 的产生 pipe是有一定容量的1，这一部分就是内核维护的缓冲区。当pipe的读端试图对文件描述符执行read()系统调用的时候，内核会先检查缓冲区是否有数据，有则返回; 若没有，则根据读端文件描述符具体是否以阻塞标志打开，如阻塞，则阻塞至缓冲区有数据，或者当对端已经关闭文件描述符的时候，读端的read()调用会返回0, 这就是所谓的EOF。对pipe的写端执行close()并不会刷新pipe的缓冲区，而且读端也并不能立即察觉到写端已经关闭。这引发了一个问题，也是我在开发过程中碰到的一个很大的问题。如果写端在关闭后，在pipe的缓冲区还没被读端读取完的时候，重新打开并写入数据，这部分数据会写入原先的缓冲区并被读端继续读取。
FIFO 的正确使用姿势 上文提到的EOF并未被读端及时响应还会造成另一个问题。如果写端关闭后立即执行open()系统调用，这个函数不会阻塞，因为读端确实正处于打开的状态。另一方面，读端关闭后立即执行也不会阻塞。这对程序的逻辑造成了致命的影响，它让读端误以为第二次打开的是一个新的文件，同时让写端误以为读端已经在请求新文件的数据。
所以FIFO的正确使用姿势应该是在写端open()之后立即unlink()然后再mkfifo():
wfd = open(filename, O_WRONLY, NULL); unlink(filename); mkfifo(filename, FIFO_MODE); 虽然对FIFO进行了unlink(), 文件已经不存在，但是内核实际上还在维护读写两端的文件描述符和对应的缓冲区。而第二次mkfifo()即使创建的FIFO的名字是一样的，内核会为它维护另一套空间。这样的话，无论是读端还是写端，连续的两次open()都会阻塞。而且打开后缓冲区是空的。
二阶指针 二阶指针玩链表其实还是蛮有意思的嘛(虽然只是少定义一个中间变量)&amp;hellip;
stdin, stdout, stderr and tty /dev/{stdin,stdout,stderr}默认分别是/proc/self/fd/{0,1,2}的软链接，而/proc/self/fd/{0,1,2}默认都是pts或者tty的软链接，所以stdin, stdout, stderr默认就是终端设备。当stdin被 shell 用管道替换之后，可以用以下方式重新打开键盘输入(另外两个类似):
#include &amp;lt;unistd.h&amp;gt; /* for dup2(), close() and STDIN_FILENO */#include &amp;lt;fcntl.h&amp;gt; /* for open() and O_RDONLY */ int realstdin = open(&amp;#34;/dev/tty&amp;#34;, O_RDONLY); dup2(realstdin, STDIN_FILENO); close(realstdin); /dev/tty总是当前终端设备
More 想到什么我再更新吧。
pipe(7) - Linux man page&amp;#160;&amp;#x21a9;&amp;#xfe0e;</description></item><item><title>How do you read source code?</title><link>https://cubl.in/2014/12/repost-how-do-you-read-source-code/</link><pubDate>Fri, 19 Dec 2014 00:00:00 +0000</pubDate><guid>https://cubl.in/2014/12/repost-how-do-you-read-source-code/</guid><description>Originally posted here
If software is eating the world as Marc Andreessen and I think, how do you [r]ea(d|t) source code?
Well, let&amp;rsquo;s first answer why you should be good at reading source code at all.
First it&amp;rsquo;s always great fun to figure out how things work. By reading source code one is exactly doing that to learn about interesting software systems and projects.
Another reason for reading source code may be to get better (and faster) at reading and writing software by learning from others and sometimes also from their mistakes.</description></item><item><title>do {…} while (0) — What is it good for?</title><link>https://cubl.in/2014/12/c-do-while-in-macros/</link><pubDate>Wed, 17 Dec 2014 00:00:00 +0000</pubDate><guid>https://cubl.in/2014/12/c-do-while-in-macros/</guid><description>Originally posted in stackoverflow
It&amp;rsquo;s the only construct in C that you can use to #define a multistatement operation, put a semicolon after, and still use within an if statement. An example might help:
#define FOO(x) foo(x); bar(x) if (condition) FOO(x); else // syntax error here ...; Even using braces doesn&amp;rsquo;t help:
#define FOO(x) { foo(x); bar(x); } Using this in an if statement would require that you omit the semicolon, which is counterintuitive:</description></item><item><title>Hello World</title><link>https://cubl.in/2014/12/hello-world/</link><pubDate>Tue, 16 Dec 2014 00:00:00 +0000</pubDate><guid>https://cubl.in/2014/12/hello-world/</guid><description>之前挂 wordpress 的 vps 快到期了，有 do 免费用都不想续费了。一直觉得 wordpress 很臃肿，刚好趁这次机会把 blog 换成 jekyll。
现在这个 blog 是挂在 github 上的，vps 只是做了个 proxy_pass, 欢迎到我的 github 主页 fork.
UPDATE: 2016-01-20 今天把 / 和 /blog/ 都放在 github 上，反正都是静态页面，没必要 vps 处理。然后用 cloudfare 做了 cdn, 这个站已经和 vps 没关系了。</description></item><item><title>Writeup-Training: Warchall - 7 Tropical Fruits</title><link>https://cubl.in/2014/05/wechall-tropic-writeup/</link><pubDate>Wed, 14 May 2014 00:00:00 +0000</pubDate><guid>https://cubl.in/2014/05/wechall-tropic-writeup/</guid><description>Wechall的tropic这道题真是撸得我考试周复(yu)习(xi)都没心思了，花了两天半终于搞定了，才63人做出来的题目居然是training！！！
做这题的时候也是我第一次写shellcode，不过这道题难点不在于shellcode怎么写，而在于坑爹的ASLR。不说stack的地址一直在变，居然连linux-gate.so都在变！
一开始查了好久，发现个思路叫ret2libc，然后我gdb了一下，发现system()的地址虽然是随机的，但是有6位是不变的。然后我就撸啊撸，撸了个shell脚本，速度不错，居然半分钟之内就能把system(“sh”)跑出来。看到”sh-4.2$”的时候我那叫一个激动啊。坑爹的是system()这货执行的时候居然会丢掉suid的权限(man system#NOTES)。
所以忙活了一天，我的成果就是，在一个shell下面，再开一个shell……
然后第二天我不甘心啊，就找啊找找啊找，找到了exec函数族。
#include &amp;lt;unistd.h&amp;gt;extern char **environ; int execl(const char *path, const char *arg, ...); int execlp(const char *file, const char *arg, ...); int execle(const char *path, const char *arg, ..., char * const envp[]); int execv(const char *path, char *const argv[]); int execvp(const char *file, char *const argv[]); int execve(const char *path, char *const argv[], char *const envp[]); //其中只有execve是真正意义上的系统调用，其它都是在此基础上经过包装的库函数。 这货厉害，suid会传递下去，但是悲催的是每个函数的参数不止一个，而且大多都要求最后一个参数为NULL(直接无视)，但是execv之类的函数又不方便构造后面的那些二阶指针，所以我昨天就是在满屏的Segmentation Fault中度过的，偶尔出现的Invalid Instruction能让人高兴好一阵。
第二天无果，不过我cat了一下compile7.sh，发现了好玩的东西
#!/bin/bash gcc -fno-stack-protector -z execstack level7.</description></item><item><title>KDE窗口撕裂的解决办法</title><link>https://cubl.in/2014/03/kde%E7%AA%97%E5%8F%A3%E6%92%95%E8%A3%82%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</link><pubDate>Sat, 22 Mar 2014 00:00:00 +0000</pubDate><guid>https://cubl.in/2014/03/kde%E7%AA%97%E5%8F%A3%E6%92%95%E8%A3%82%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</guid><description>问题 从去年装archliux+kde开始就一直被kde窗口拖动时的残影和撕裂感折磨，之前观摩前辈 @撸神 的kde的时候发现了这个问题，他说这是kde的bug，所以这个问题就一直放着，直到昨天帮 @古真 装arch才开始注意。
最初以为是垂直同步没有开启，结果archwiki上提到intel集显是默认开启垂直同步的。尝试了一下，不论是开启还是关闭垂直同步实际上对这个问题都没有任何帮助。
解决办法 今天翻遍了archwiki，在Intel Graphics页面发现了解决办法，其中SNA是默认的模式。
播放视频时屏幕撕裂 若使用 SNA，将下列内容添加到 /etc/X11/xorg.conf.d/20-intel.conf 的 Device 段可杜绝屏幕撕裂问题。
Option &amp;ldquo;TearFree&amp;rdquo; &amp;ldquo;true&amp;rdquo;
如果20-intel.conf不存在可以创建一个。最简单的示例如下：
Section &amp;#34;Device&amp;#34; Identifier &amp;#34;Intel Graphics&amp;#34; Driver &amp;#34;intel&amp;#34; Option &amp;#34;TearFree&amp;#34; &amp;#34;true&amp;#34; EndSection 参考 1: Intel Graphics(Archwiki)</description></item><item><title>[转] C中的可变参数研究</title><link>https://cubl.in/2014/02/c%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E7%9A%84%E7%A0%94%E7%A9%B6/</link><pubDate>Tue, 25 Feb 2014 00:00:00 +0000</pubDate><guid>https://cubl.in/2014/02/c%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E7%9A%84%E7%A0%94%E7%A9%B6/</guid><description>初学C，感觉可变参数挺好玩的，转载一发做个mark。本想注明来源，发现来源也是转载的，找不到根源，就不贴链接了。
一. 何谓可变参数 int printf(const char* format, ...); 这是使用过C语言的人所再熟悉不过的printf函数原型，它的参数中就有固定参数format和可变参数（用”…”表示）. 而我们又可以用各种方式来调用printf,如:
printf(&amp;#34;%d&amp;#34;,value); printf(&amp;#34;%s&amp;#34;,str); printf(&amp;#34;the number is %d,string is: %s&amp;#34;, value, str); 二. 实现原理 C语言用宏来处理这些可变参数。这些宏看起来很复杂，其实原理挺简单，就是根据参数入栈的特点从最靠近第一个可变参数的固定参数开始，依次获取每个可变参数的地址。下面我们来分析这些宏。在VC中的stdarg.h头文件中，针对不同平台有不同的宏定义，我们选取X86平台下的宏定义：
typedef char *va_list; /*把va_list被定义成char*，这是因为在我们目前所用的PC机上，字符指针类型可以用来存储内存单元地址。而在有的机器上va_list是被定义成void*的*/ #define _INTSIZEOF(n) ((sizeof(n) + sizeof(int) - 1) &amp;amp; ~(sizeof(int) - 1)) /*_INTSIZEOF(n)宏是为了考虑那些内存地址需要对齐的系统，从宏的名字来应该是跟sizeof(int)对齐。一般的sizeof(int)=4，也就是参数在内存中的地址都为4的倍数。比如，如果sizeof(n)在1－4之间，那么_INTSIZEOF(n)＝4；如果sizeof(n)在5－8之间，那么_INTSIZEOF(n)=8。*/ #define va_start(ap,v)(ap = (va_list)&amp;amp;v + _INTSIZEOF(v)) /*va_start的定义为 &amp;amp;v+_INTSIZEOF(v), 这里&amp;amp;v是最后一个固定参数的起始地址，再加上其实际占用大小后，就得到了第一个可变参数的起始内存地址。所以我们运行va_start(ap, v)以后,ap指向第一个可变参数在的内存地址*/ #define va_arg(ap,t) (*(t*)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t))) /*这个宏做了两个事情， ①用用户输入的类型名对参数地址进行强制类型转换，得到用户所需要的值 ②计算出本参数的实际大小，将指针调到本参数的结尾，也就是下一个参数的首地址，以便后续处理。*/ #define va_end(ap) (ap = (va_list)0) /*x86平台定义为ap=(char*)0;使ap不再指向堆栈,而是跟NULL一样.有些直接定义为((void*)0),这样编译器不会为va_end产生代码,例如gcc在linux的x86平台就是这样定义的.在这里大家要注意一个问题:由于参数的地址用于va_start宏,所以参数不能声明为寄存器变量或作为函数或数组类型.*/ 以下再用图来表示~~(这什么破图)~~:
在VC等绝大多数C编译器中，默认情况下，参数进栈的顺序是由右向左的，因此，参数进栈以后的内存模型如下图所示：最后一个固定参数的地址位于第一个可变参数之下，并且是连续存储的。
三. printf研究 下面是一个简单的printf函数的实现。（作者简直是幽默，所谓printf函数的实现里面居然用到了printf函数。。。）</description></item><item><title>通过DNS隧道绕过portal认证</title><link>https://cubl.in/2014/02/%E9%80%9A%E8%BF%87dns%E9%9A%A7%E9%81%93%E7%BB%95%E8%BF%87portal%E8%AE%A4%E8%AF%81/</link><pubDate>Tue, 11 Feb 2014 00:00:00 +0000</pubDate><guid>https://cubl.in/2014/02/%E9%80%9A%E8%BF%87dns%E9%9A%A7%E9%81%93%E7%BB%95%E8%BF%87portal%E8%AE%A4%E8%AF%81/</guid><description>&lt;blockquote>
&lt;p>        Portal在英语中是入口的意思。Portal认证通常也称为Web认证，一般将Portal认证网站称为门户网站。未认证用户上网时，设备强制用户登录到特定站点，用户可以免费访问其中的服务。当用户需要使用互联网中的其它信息时，必须在门户网站进行认证，只有认证通过后才可以使用互联网资源。用户可以主动访问已知的Portal认证网站，输入用户名和密码进行认证，这种开始Portal认证的方式称作主动认证。反之，如果用户试图通过HTTP访问其他外网，将被强制访问Portal认证网站，从而开始Portal认证过程，这种方式称作强制认证。&lt;/p>
&lt;/blockquote>
&lt;p>比如说：华某科校园网(无线端), Chinanet, CMCC, China-Unicom&lt;/p>
&lt;p>（华某科校园网升级后，DNS隧道被一定程度限用，处于半残状态。基本无法使用。）&lt;/p>
&lt;p>portal认证不同于pppoe，它已经通过DHCP对Client分发IP，但是在完成认证前会强制重定向url到protal认证界面，只有登录后才能顺利的访问网络。不过portal认证&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->并没有阻止DNS查询&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->的请求，通过一定手段可以绕过portal认证，直接访问internet。我们需要的软件就是iodine&lt;/p>
&lt;blockquote>
&lt;p>iodine lets you tunnel IPv4 data through a DNS server. This can be usable in different situations where internet access is firewalled, but DNS queries are allowed.&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;/blockquote></description></item></channel></rss>