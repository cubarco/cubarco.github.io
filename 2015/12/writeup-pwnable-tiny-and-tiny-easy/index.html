<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=generator content="Hugo 0.83.1"><title>Writeup-Pwnable: tiny & tiny_easy - /home/cubarco</title><meta property="og:title" content="Writeup-Pwnable: tiny & tiny_easy - /home/cubarco"><link href=https://cubar.co/favicon.ico rel=icon type=image/x-icon><meta name=description content="Hack, CTF, Writeup, Exploitation, ROP"><link rel=stylesheet href=/css/main.min.3bcbe33ae5c46485bcebc6352fc91232f950eb735ccac53f81bd19d79251ba9c.css media=all></head><body><div class=wrapper><header class=header><nav class=nav><a href=/ class=nav-logo><img src=/images/logo-min.png width=50 height=50 alt=Logo></a><ul class=nav-links><li><a href=/>Index</a></li><li><a href=/tags/>Tags</a></li><li><a href=/about/>About</a></li><li><a href=/links/>Links</a></li><li><a href=https://github.com/cubarco/cubarco.github.io>GitHub</a></li></ul></nav></header><main class=content role=main><article class=article><h1 class=article-title>Writeup-Pwnable: tiny & tiny_easy</h1><span class=article-date>2015-12-11</span>
<a class=article-tag href=/tags/hack>Hack</a>
<a class=article-tag href=/tags/ctf>CTF</a>
<a class=article-tag href=/tags/writeup>Writeup</a>
<a class=article-tag href=/tags/exploitation>Exploitation</a>
<a class=article-tag href=/tags/rop>ROP</a><div class=article-content><h2 id=tiny_easy>tiny_easy</h2><h3 id=1-brute-force>1. Brute force</h3><p>这题的 bin 拿到之后开 gdb 看了一下 mapping, 发现 stack 是可执行的(如果 ELF 没有 GNU_STACK 这个 header, 则默认 stack 可执行<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>)。所以思路很明显了。</p><p>看一下反汇编:</p><div class=highlight><pre class=chroma><code class=language-plain data-lang=plain>8048054:	58             pop %eax
8048055:	5a             pop %edx
8048056:	8b12           mov (%edx),%edx
8048058:	ffd2           call *%edx
</code></pre></div><p>然后用 gdb 断在 entry point, 观察一下栈:</p><div class=highlight><pre class=chroma><code class=language-plain data-lang=plain>$ gdb tiny_easy
(gdb) b *0x8048054
Breakpoint 1 at 0x8048054
(gdb) r
Starting program: /home/tiny_easy/tiny_easy

Breakpoint 1, 0x08048054 in ?? ()
(gdb) x/32wx $esp
0xffd82d70: 0x00000001  0xffd84df5  0x00000000  0xffd84e0f
0xffd82d80: 0xffd84e1f  0xffd84e33  0xffd84e54  0xffd84e68
0xffd82d90: 0xffd84e77  0xffd84e83  0xffd84ed0  0xffd84ee9
0xffd82da0: 0xffd84ef8  0xffd84f0c  0xffd84f1d  0xffd84f63
0xffd82db0: 0xffd84f6c  0xffd84f81  0xffd84f89  0xffd84f99
0xffd82dc0: 0xffd84fab  0x00000000  0x00000020  0xf776bb50
0xffd82dd0: 0x00000021  0xf776b000  0x00000010  0x0fabfbff
0xffd82de0: 0x00000006  0x00001000  0x00000011  0x00000064
</code></pre></div><p>发现 $esp 位置是命令行参数的个数(即 argc)，后面借着的都是 argv[i], 以 NULL 结尾，再之后都是环境变量(即 envp)。</p><p>观察到这里，这题就有了一个很明显的解法，即在 argv[0] 里面放猜测的栈中的某个地址，然后跳到存在 argv[1&mldr;n] 里面的 shellcode. 但是由于 ASLR, 需要用很多 nop 来填充 stack, 来增加 bruteforce 的命中率。</p><h4 id=exptiny_easyc>exp.tiny_easy.c</h4><code class=gist data-gist-id=cubarco/03fb090852a3303f58db data-gist-file=pwnable-rookiss-tiny-easy.c><p>Gist: <a href=https://gist.github.com/cubarco/03fb090852a3303f58db>cubarco/03fb090852a3303f58db</a></p></code><h3 id=2-vdso2>2. vDSO<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup></h3><p>这个思路是在做 tiny 的时候得来的。简单来说就是利用 vdso 里面的 gadgets 准确的跳到 shellcode。虽然 ASLR 会导致 vdso 的加载位置随机，但是在 shell 中执行<code>ulimit -s unlimited</code>可以关掉随机 mmap<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>.</p><p><em>vdso 可以在 gdb 调试的时候用 dump<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup> 命令导出。</em></p><h4 id=exptiny_easypy>exp.tiny_easy.py</h4><code class=gist data-gist-id=cubarco/03fb090852a3303f58db data-gist-file=pwnable-rookiss-tiny-easy.py><p>Gist: <a href=https://gist.github.com/cubarco/03fb090852a3303f58db>cubarco/03fb090852a3303f58db</a></p></code><h2 id=tiny>tiny</h2><p>这题就是 tiny_easy 开 NX 的版本，只好 ROP. 能用的 gadgets 只有 vdso 和 text 段 6 个字节的指令(哭).</p><p>具体怎么构造 ROP, 绞尽脑汁想了很久。目的就是一个: <code>execv("/bin/sh")</code>，而执行这个系统调用需要将 eax 设置为 0xb，ebx 设置为字符串指针。前者很容易实现，只要控制 argc 为 11 就可以，麻烦的是 ebx.</p><p>一开始想怎么改 ebp 和 esp 的值，让 ret 指令返回地址能受我的控制，之后方便构造 ROP chain. 在草稿纸上写写画画试了很久没有成功，遂放弃。之后洗了个澡，回来重新看 stack 里面的内容，有了很重要的收获。</p><div class=highlight><pre class=chroma><code class=language-plain data-lang=plain>(gdb) x/32wx $esp
...
0xffd82dc0: 0xffd84fab  0x00000000  0x00000020  0xf776bb50
0xffd82dd0: 0x00000021  0xf776b000  0x00000010  0x0fabfbff
...
</code></pre></div><p>截取了上文中的一部分 stack 数据，可以发现在 0xffd82dec 的位置有个 0xf776bb50, 看了一下，是 vdso 中<code>__kernel_vsyscall</code>的起始位置，如果可以 ret 到这里，就能调用系统调用了。</p><p>然后开始找 gadgets.</p><div class=highlight><pre class=chroma><code class=language-plain data-lang=plain>5c8:	83 c4 3c             	add    $0x3c,%esp
5cb:	5b                   	pop    %ebx
5cc:	5e                   	pop    %esi
5cd:	5f                   	pop    %edi
5ce:	5d                   	pop    %ebp
5cf:	c3                   	ret
</code></pre></div><p>GOTCHA!!! 这里将栈指针增加了 0x3c, 然后<code>pop %ebx</code>顺便满足了 execv 系统调用的第二个要求。仔细观察了栈的内容，只要保证有 11 个命令行参数，5 个环境变量就能完成 execv 的调用，其中第四个环境变量的字符串是执行路径。</p><h4 id=exptinysh>exp.tiny.sh</h4><p>这个 exp 的核心是 C (其实就是一句<code>execle()</code>的事情), 用 shell 写只是为了方便，可以把<code>ulimit -s unlimited</code>这些命令放在一起(调试过程中还用到了其他命令，最后删的只剩 ulimit&mldr;)，而且用一个脚本解题本身是一件很酷的事情XD.</p><code class=gist data-gist-id=cubarco/d379e31c9487c8ee07f2 data-gist-file=pwnable-hackerssecret-tiny.sh><p>Gist: <a href=https://gist.github.com/cubarco/d379e31c9487c8ee07f2>cubarco/d379e31c9487c8ee07f2</a></p></code><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p><a href=https://wiki.gentoo.org/wiki/Hardened/GNU_stack_quickstart#Causes_of_executable_stack_markings>Causes of executable stack markings</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2 role=doc-endnote><p><a href=https://en.wikipedia.org/wiki/VDSO>vDSO</a>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3 role=doc-endnote><p><a href=http://security.cs.pub.ro/hexcellents/wiki/kb/exploiting/home#address-space-layout-randomization>Address space layout randomization</a>&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4 role=doc-endnote><p><a href=https://sourceware.org/gdb/onlinedocs/gdb/Dump_002fRestore-Files.html>Debugging with GDB#Copy Between Memory and a File</a>&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></div></article><script src=https://utteranc.es/client.js repo=cubarco/cubarco.github.io issue-term=pathname label="Comments 💬" theme=boxy-light crossorigin=anonymous async defer></script></main><footer class=footer><ul class=footer-links><li><a href=/index.xml type=application/rss+xml target=_blank>RSS feed</a></li><li><a href=https://gohugo.io/ class=footer-links-kudos target=_blank rel="noopener norefferrer">Made with <img src=/images/hugo-logo.png alt="Img link to Hugo website" width=22 height=22></a></li><li><a>© 2014 - 2021</a></li></ul></footer></div><script async src=https://cdn.jsdelivr.net/gh/cubarco/cubarco.github.io@gh-pages/js/async.min.e8b856a43b93a78048deb0cb92ad99794ad3acb0a2c8093599a653ece0f0a17be8763cdfc99be237c1100cf84542be5aeebc0a7cac0935c48e7b3c95b87c6f34.js onload=window.GistEmbed.init()></script><script async defer src=https://cdn.jsdelivr.net/npm/instant.page@5.1.0/instantpage.min.js></script><script>window.ga_tid="UA-54867602-1",window.ga_api="https://cubar.co/ga-proxy/"</script><script src=https://cdn.jsdelivr.net/npm/cfga@1.0.3 async defer></script><script async defer data-website-id=e9fdcc32-0bfa-4de5-beb0-3bbf1e4638ab src=https://umami.2oo.in/umami.js></script></body></html>