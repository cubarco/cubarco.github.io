<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=generator content="Hugo 0.83.1"><title>Writeup-Pwnable: tiny & tiny_easy - /home/cubl</title><meta property="og:title" content="Writeup-Pwnable: tiny & tiny_easy - /home/cubl"><link href=/favicon.ico rel=icon type=image/x-icon><meta name=description content="Pwning for fun."><link rel=stylesheet href=https://cdn.jsdelivr.net/gh/cubarco/cubarco.github.io@gh-pages/css/main.min.9861353c7baacf2268a74fe7ea9d3bd8211eada1554a630c4d29fb448bfae5fb8f43ea02baa52d2ca079d0027f37aa8f058ab0362f4301e9a9b77538d71b549b.css media=all></head><body><div class=wrapper><header class=header><nav class=nav><a href=/ class=nav-logo><img src=/images/logo-min.png width=50 height=50 alt=Logo></a><ul class=nav-links><li><a href=/>Index</a></li><li><a href=/tags/>Tags</a></li><li><a href=/about/>About</a></li><li><a href=https://github.com/cubarco/cubarco.github.io>GitHub</a></li></ul></nav></header><main class=content role=main><article class=article><h1 class=article-title>Writeup-Pwnable: tiny & tiny_easy</h1><span class=article-date>2015-12-11</span>
<a class=article-tag href=/tags/hack>Hack</a>
<a class=article-tag href=/tags/ctf>CTF</a>
<a class=article-tag href=/tags/writeup>Writeup</a>
<a class=article-tag href=/tags/exploitation>Exploitation</a>
<a class=article-tag href=/tags/rop>ROP</a><div class=article-content><h2 id=tiny_easy>tiny_easy</h2><h3 id=1-brute-force>1. Brute force</h3><p>这题的 bin 拿到之后开 gdb 看了一下 mapping, 发现 stack 是可执行的(如果 ELF 没有 GNU_STACK 这个 header, 则默认 stack 可执行<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>)。所以思路很明显了。</p><p>看一下反汇编:</p><div class=highlight><pre class=chroma><code class=language-plain data-lang=plain>8048054:	58             pop %eax
8048055:	5a             pop %edx
8048056:	8b12           mov (%edx),%edx
8048058:	ffd2           call *%edx
</code></pre></div><p>然后用 gdb 断在 entry point, 观察一下栈:</p><div class=highlight><pre class=chroma><code class=language-plain data-lang=plain>$ gdb tiny_easy
(gdb) b *0x8048054
Breakpoint 1 at 0x8048054
(gdb) r
Starting program: /home/tiny_easy/tiny_easy

Breakpoint 1, 0x08048054 in ?? ()
(gdb) x/32wx $esp
0xffd82d70: 0x00000001  0xffd84df5  0x00000000  0xffd84e0f
0xffd82d80: 0xffd84e1f  0xffd84e33  0xffd84e54  0xffd84e68
0xffd82d90: 0xffd84e77  0xffd84e83  0xffd84ed0  0xffd84ee9
0xffd82da0: 0xffd84ef8  0xffd84f0c  0xffd84f1d  0xffd84f63
0xffd82db0: 0xffd84f6c  0xffd84f81  0xffd84f89  0xffd84f99
0xffd82dc0: 0xffd84fab  0x00000000  0x00000020  0xf776bb50
0xffd82dd0: 0x00000021  0xf776b000  0x00000010  0x0fabfbff
0xffd82de0: 0x00000006  0x00001000  0x00000011  0x00000064
</code></pre></div><p>发现 $esp 位置是命令行参数的个数(即 argc)，后面借着的都是 argv[i], 以 NULL 结尾，再之后都是环境变量(即 envp)。</p><p>观察到这里，这题就有了一个很明显的解法，即在 argv[0] 里面放猜测的栈中的某个地址，然后跳到存在 argv[1&mldr;n] 里面的 shellcode. 但是由于 ASLR, 需要用很多 nop 来填充 stack, 来增加 bruteforce 的命中率。</p><h4 id=exptiny_easyc>exp.tiny_easy.c</h4><div class=gist data-gist=cubarco/03fb090852a3303f58db data-gist-file=pwnable-rookiss-tiny-easy.c><p>Gist: <a href=https://gist.github.com/cubarco/03fb090852a3303f58db>cubarco/03fb090852a3303f58db</a></p></div><h3 id=2-vdso2>2. vDSO<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup></h3><p>这个思路是在做 tiny 的时候得来的。简单来说就是利用 vdso 里面的 gadgets 准确的跳到 shellcode。虽然 ASLR 会导致 vdso 的加载位置随机，但是在 shell 中执行<code>ulimit -s unlimited</code>可以关掉随机 mmap<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>.</p><p><em>vdso 可以在 gdb 调试的时候用 dump<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup> 命令导出。</em></p><h4 id=exptiny_easypy>exp.tiny_easy.py</h4><div class=gist data-gist=cubarco/03fb090852a3303f58db data-gist-file=pwnable-rookiss-tiny-easy.py><p>Gist: <a href=https://gist.github.com/cubarco/03fb090852a3303f58db>cubarco/03fb090852a3303f58db</a></p></div><h2 id=tiny>tiny</h2><p>这题就是 tiny_easy 开 NX 的版本，只好 ROP. 能用的 gadgets 只有 vdso 和 text 段 6 个字节的指令(哭).</p><p>具体怎么构造 ROP, 绞尽脑汁想了很久。目的就是一个: <code>execv("/bin/sh")</code>，而执行这个系统调用需要将 eax 设置为 0xb，ebx 设置为字符串指针。前者很容易实现，只要控制 argc 为 11 就可以，麻烦的是 ebx.</p><p>一开始想怎么改 ebp 和 esp 的值，让 ret 指令返回地址能受我的控制，之后方便构造 ROP chain. 在草稿纸上写写画画试了很久没有成功，遂放弃。之后洗了个澡，回来重新看 stack 里面的内容，有了很重要的收获。</p><div class=highlight><pre class=chroma><code class=language-plain data-lang=plain>(gdb) x/32wx $esp
...
0xffd82dc0: 0xffd84fab  0x00000000  0x00000020  0xf776bb50
0xffd82dd0: 0x00000021  0xf776b000  0x00000010  0x0fabfbff
...
</code></pre></div><p>截取了上文中的一部分 stack 数据，可以发现在 0xffd82dec 的位置有个 0xf776bb50, 看了一下，是 vdso 中<code>__kernel_vsyscall</code>的起始位置，如果可以 ret 到这里，就能调用系统调用了。</p><p>然后开始找 gadgets.</p><div class=highlight><pre class=chroma><code class=language-plain data-lang=plain>5c8:	83 c4 3c             	add    $0x3c,%esp
5cb:	5b                   	pop    %ebx
5cc:	5e                   	pop    %esi
5cd:	5f                   	pop    %edi
5ce:	5d                   	pop    %ebp
5cf:	c3                   	ret
</code></pre></div><p>GOTCHA!!! 这里将栈指针增加了 0x3c, 然后<code>pop %ebx</code>顺便满足了 execv 系统调用的第二个要求。仔细观察了栈的内容，只要保证有 11 个命令行参数，5 个环境变量就能完成 execv 的调用，其中第四个环境变量的字符串是执行路径。</p><h4 id=exptinysh>exp.tiny.sh</h4><p>这个 exp 的核心是 C (其实就是一句<code>execle()</code>的事情), 用 shell 写只是为了方便，可以把<code>ulimit -s unlimited</code>这些命令放在一起(调试过程中还用到了其他命令，最后删的只剩 ulimit&mldr;)，而且用一个脚本解题本身是一件很酷的事情XD.</p><div class=gist data-gist=cubarco/d379e31c9487c8ee07f2 data-gist-file=pwnable-hackerssecret-tiny.sh><p>Gist: <a href=https://gist.github.com/cubarco/d379e31c9487c8ee07f2>cubarco/d379e31c9487c8ee07f2</a></p></div><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p><a href=https://wiki.gentoo.org/wiki/Hardened/GNU_stack_quickstart#Causes_of_executable_stack_markings>Causes of executable stack markings</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2 role=doc-endnote><p><a href=https://en.wikipedia.org/wiki/VDSO>vDSO</a>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3 role=doc-endnote><p><a href=http://security.cs.pub.ro/hexcellents/wiki/kb/exploiting/home#address-space-layout-randomization>Address space layout randomization</a>&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4 role=doc-endnote><p><a href=https://sourceware.org/gdb/onlinedocs/gdb/Dump_002fRestore-Files.html>Debugging with GDB#Copy Between Memory and a File</a>&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></div></article><script src=https://utteranc.es/client.js repo=cubarco/cubarco.github.io issue-term=pathname theme=boxy-light crossorigin=anonymous async></script></main><footer class=footer><ul class=footer-links><li><a href=/index.xml type=application/rss+xml target=_blank>RSS feed</a></li><li><a href=https://gohugo.io/ class=footer-links-kudos target=_blank rel="noopener norefferrer">Made with <img src=/images/hugo-logo.png alt="Img link to Hugo website" width=22 height=22></a></li><li><a>© 2014 - 2015</a></li></ul></footer></div><script src=https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js async></script><script src=https://cdn.jsdelivr.net/gh/cubarco/cubarco.github.io@gh-pages/js/main.min.60d77477267181e7581bba5435ded18ab8ff1db3955dde2d3afeec25cc51d24e32b178b6c1ebb5edc2a4cef04c8f592408eb2811f0c78c9295b8a0939977a6a1.js async></script><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-54867602-1','auto'),ga('send','pageview'))</script><script async defer data-website-id=e9fdcc32-0bfa-4de5-beb0-3bbf1e4638ab src=https://umami.pwn.ooo/umami.js></script></body></html>