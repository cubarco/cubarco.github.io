<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=generator content="Hugo 0.83.1"><title>Paf 开发总结 - /home/cubl</title><meta property="og:title" content="Paf 开发总结 - /home/cubl"><link href=https://cubl.in/favicon.ico rel=icon type=image/x-icon><meta name=description content="FIFO, Linux, Pipe"><link rel=stylesheet href=/css/main.min.3bcbe33ae5c46485bcebc6352fc91232f950eb735ccac53f81bd19d79251ba9c.css media=all></head><body><div class=wrapper><header class=header><nav class=nav><a href=/ class=nav-logo><img src=/images/logo-min.png width=50 height=50 alt=Logo></a><ul class=nav-links><li><a href=/>Index</a></li><li><a href=/tags/>Tags</a></li><li><a href=/about/>About</a></li><li><a href=https://github.com/cubarco/cubarco.github.io>GitHub</a></li></ul></nav></header><main class=content role=main><article class=article><h1 class=article-title>Paf 开发总结</h1><span class=article-date>2014-12-31</span>
<a class=article-tag href=/tags/fifo>FIFO</a>
<a class=article-tag href=/tags/linux>Linux</a>
<a class=article-tag href=/tags/pipe>Pipe</a><div class=article-content><p><a href=https://github.com/cubarco/paf title="Pipe as File Github Homepage">Paf (Pipe as file)</a> 并不是什么大项目，只是一时兴起为满足自己奇怪需求而开发的小工具。具体的介绍都摆在 Github 上了，这里就不赘述了。只是对开发过程中遇到的一些问题和技巧做一下总结。</p><h2 id=eof-的产生>EOF 的产生</h2><p><code>pipe</code>是有一定容量的<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>，这一部分就是内核维护的缓冲区。当<code>pipe</code>的读端试图对文件描述符执行<code>read()</code>系统调用的时候，内核会先检查缓冲区是否有数据，有则返回; 若没有，则根据读端文件描述符具体是否以阻塞标志打开，如阻塞，则阻塞至缓冲区有数据，或者当对端已经关闭文件描述符的时候，读端的<code>read()</code>调用会返回0, 这就是所谓的<code>EOF</code>。对<code>pipe</code>的写端执行<code>close()</code>并不会刷新<code>pipe</code>的缓冲区，而且读端也并不能立即察觉到写端已经关闭。这引发了一个问题，也是我在开发过程中碰到的一个很大的问题。如果写端在关闭后，在<code>pipe</code>的缓冲区还没被读端读取完的时候，重新打开并写入数据，这部分数据会写入原先的缓冲区并被读端继续读取。</p><h2 id=fifo-的正确使用姿势>FIFO 的正确使用姿势</h2><p>上文提到的<code>EOF</code>并未被读端及时响应还会造成另一个问题。如果写端关闭后立即执行<code>open()</code>系统调用，这个函数不会阻塞，因为读端确实正处于打开的状态。另一方面，读端关闭后立即执行也不会阻塞。这对程序的逻辑造成了致命的影响，它让读端误以为第二次打开的是一个新的文件，同时让写端误以为读端已经在请求新文件的数据。</p><p>所以<code>FIFO</code>的正确使用姿势应该是在写端<code>open()</code>之后立即<code>unlink()</code>然后再<code>mkfifo()</code>:</p><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=n>wfd</span> <span class=o>=</span> <span class=n>open</span><span class=p>(</span><span class=n>filename</span><span class=p>,</span> <span class=n>O_WRONLY</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
<span class=n>unlink</span><span class=p>(</span><span class=n>filename</span><span class=p>);</span>
<span class=n>mkfifo</span><span class=p>(</span><span class=n>filename</span><span class=p>,</span> <span class=n>FIFO_MODE</span><span class=p>);</span>
</code></pre></div><p>虽然对<code>FIFO</code>进行了<code>unlink()</code>, 文件已经不存在，但是内核实际上还在维护读写两端的文件描述符和对应的缓冲区。而第二次<code>mkfifo()</code>即使创建的<code>FIFO</code>的名字是一样的，内核会为它维护另一套空间。这样的话，无论是读端还是写端，连续的两次<code>open()</code>都会阻塞。而且打开后缓冲区是空的。</p><h2 id=二阶指针>二阶指针</h2><p>二阶指针玩链表其实还是蛮有意思的嘛(虽然只是少定义一个中间变量)&mldr;</p><h2 id=stdin-stdout-stderr-and-tty>stdin, stdout, stderr and tty</h2><p><code>/dev/{stdin,stdout,stderr}</code>默认分别是<code>/proc/self/fd/{0,1,2}</code>的软链接，而<code>/proc/self/fd/{0,1,2}</code>默认都是<code>pts</code>或者<code>tty</code>的软链接，所以<code>stdin</code>, <code>stdout</code>, <code>stderr</code>默认就是终端设备。当<code>stdin</code>被 shell 用管道替换之后，可以用以下方式重新打开键盘输入(另外两个类似):</p><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt; /* for dup2(), close() and STDIN_FILENO */</span><span class=cp>
</span><span class=cp>#include</span> <span class=cpf>&lt;fcntl.h&gt; /* for open() and O_RDONLY */</span><span class=cp>
</span><span class=cp></span>
<span class=kt>int</span> <span class=n>realstdin</span> <span class=o>=</span> <span class=n>open</span><span class=p>(</span><span class=s>&#34;/dev/tty&#34;</span><span class=p>,</span> <span class=n>O_RDONLY</span><span class=p>);</span>
<span class=n>dup2</span><span class=p>(</span><span class=n>realstdin</span><span class=p>,</span> <span class=n>STDIN_FILENO</span><span class=p>);</span>
<span class=n>close</span><span class=p>(</span><span class=n>realstdin</span><span class=p>);</span>
</code></pre></div><p><code>/dev/tty</code>总是当前终端设备</p><h2 id=more>More</h2><p>想到什么我再更新吧。</p><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p><a href=http://linux.die.net/man/7/pipe>pipe(7) - Linux man page</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></div></article><script src=https://utteranc.es/client.js repo=cubarco/cubarco.github.io issue-term=pathname label="Comments 💬" theme=boxy-light crossorigin=anonymous async defer></script></main><footer class=footer><ul class=footer-links><li><a href=/index.xml type=application/rss+xml target=_blank>RSS feed</a></li><li><a href=https://gohugo.io/ class=footer-links-kudos target=_blank rel="noopener norefferrer">Made with <img src=/images/hugo-logo.png alt="Img link to Hugo website" width=22 height=22></a></li><li><a>© 2014 - 2014</a></li></ul></footer></div><script async src=https://cdn.jsdelivr.net/gh/cubarco/cubarco.github.io@gh-pages/js/async.min.b0d9795fa3e2cc73a0212db678777d853d48a6e91b7487cfa12bdafe799fe41b78cff741ec11cde1bc5f5d7c40985f4c24f1225c4164c3cb789410235ce56745.js onload=window.GistEmbed.init()></script><script async defer src=https://cdn.jsdelivr.net/npm/instant.page@5.1.0/instantpage.min.js></script><script>window.ga_tid="UA-54867602-1",window.ga_api="https://cubl.in/ga-proxy/"</script><script src=https://cdn.jsdelivr.net/npm/cfga@1.0.3 async defer></script><script async defer data-website-id=e9fdcc32-0bfa-4de5-beb0-3bbf1e4638ab src=https://umami.pwn.ooo/umami.js></script></body></html>