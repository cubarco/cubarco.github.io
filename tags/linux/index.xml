<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Linux on /home/cubarco</title><link>https://cubl.in/tags/linux/</link><description>Recent content in Linux on /home/cubarco</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sat, 09 Apr 2016 00:00:00 +0000</lastBuildDate><atom:link href="https://cubl.in/tags/linux/index.xml" rel="self" type="application/rss+xml"/><item><title>如何用 Nginx 搭建简单的 DuckDuckGo 代理站</title><link>https://cubl.in/2016/04/how-to-set-up-a-duckduckgo-proxy-site-with-nginx/</link><pubDate>Sat, 09 Apr 2016 00:00:00 +0000</pubDate><guid>https://cubl.in/2016/04/how-to-set-up-a-duckduckgo-proxy-site-with-nginx/</guid><description>最近感觉手机的网络环境经常变，在寝室 v6， 出门 v4，有的时候会懒得开代理。所以就用 cloudflare+nginx 搞了个简单的 DuckDuckGo 代理站，方便随时掏出手机搜索。没有选择代理 Google 有几点原因，一个是 vps 连 Google 经常让输验证码，再就是 DuckDuckGo 不带 cookie 的搜索结果貌似比 Google 优(?)。
Nginx nginx 的配置文件如下。domain.com 改成具体的域名，/path/to/要改成 duck.domain.com 的证书路径。/etc/letsencrypt/live/images.duck.domain.com/是 Let&amp;rsquo;s encrypt 生成证书的默认目录，稍后会提到。
Gist: cubarco/08e99fbf316a435b7935727810e40458
Cloudflare duck.domain.com 可以用 Cloudflare 做 CDN，然后 crypto 策略选 Full(非strict) 的话在服务器上可以随便给 duck.domain.com 创建个证书用，具体参照1。但是像 images.duck.domain.com 这种三级域名的话，Cloudflare 是没有给 SSL 证书的，所以只好自己在服务器上配，推荐用 Let&amp;rsquo;s encrypt 签证书，方便快捷。
Let&amp;rsquo;s encrypt Let&amp;rsquo;s encrypt 的使用细节我就不赘述了，可以看官方给的 Guide2.
这里需要的三个证书可以用如下命令生成：
./letsencrypt-auto certonly --manual -d images.duck.domain.com \ -d icons.duck.domain.com \ -d ac.</description></item><item><title>利用非标准端口 DNS 服务器避免 DNS 劫持</title><link>https://cubl.in/2016/03/avoid-dns-hijacking-with-non-standard-port-dns/</link><pubDate>Wed, 23 Mar 2016 00:00:00 +0000</pubDate><guid>https://cubl.in/2016/03/avoid-dns-hijacking-with-non-standard-port-dns/</guid><description>GFW的DNS劫持原理: 说起来挺简单,GFW对境外DNS的劫持,是在发现你请求敏感域名的DNS记录时,伪装成你请求的DNS返回一个污染的数据包给你的解析器,但并不会丢弃你向境外DNS的请求,也不会丢弃境外DNS返回的正确解析结果,他只是让错误的数据抢先回来欺骗了你的解析器而已,毕竟他直接从国内给你发污染数据怎么都比国外DNS返回正确数据要快.而解析器在先收到了欺骗数据包之后,就不会再管后面返回的正确数据了,这样你就被 DNS劫持了.1
很久以前我是用这篇 blog1提供的方法，就是用 iptables drop 掉 GFW 的假 DNS 解析包。但是 2015 年 GFW 开始采用随机 IP 污染的方式，这种黑名单的解决方案已经不可用了。后来换了 dnscrypt-proxy，还算是比较好用的。但是最近不明原因，dnscrypt-proxy 在使用一段时间之后老是卡住。尝试解决无果，就想办法找替代的方案。
前几天发现 GFW 没有劫持非标准端口的 DNS 服务器，于是想到了下面两种方法避免劫持。
iptables 将外网网卡(我这是 enp8s0)发出的 dport 是 53 的包 DNAT 给 OpenDNS 443 端口。
iptables -t nat -A OUTPUT -o enp8s0 -p udp --dport 53 \ -j DNAT --to 208.67.222.222:443 dnsmasq 以下是采用 OpenDNS 443 端口的示例配置。
port=53 no-resolv # For IPv6 # server=2620:0:ccc::2#443 server=208.67.222.222#443 listen-address=127.0.0.1 Dnsmasq 的具体使用，可以看 ArchWiki2.</description></item><item><title>一个解决 Linux 版 Dota 2 中 CJK 字符显示成方块的 Workaround</title><link>https://cubl.in/2015/05/dota2-blocky-cjk-fonts-workaround/</link><pubDate>Thu, 14 May 2015 00:00:00 +0000</pubDate><guid>https://cubl.in/2015/05/dota2-blocky-cjk-fonts-workaround/</guid><description>不知道从什么时候开始，Linux 版本的 Dota 2 中载入界面的 tips sentences 和 player name 中的中文会显示成方框，详见 issue-1688。V社基本没搭理这个 bug，只好自己动手修。
猜想是游戏内直接使用了某个字体，或者该字体不存在时调用了默认字体，但是他们不支持 CJK 字符，所以显示成方块。因为 SteamFonts 给的全是Arial字体，我猜 Dota 2 那些文本使用的字体可能是Arial，开FC_DEBUG跑了一遍发现猜的没错。那么我们要做的就是用fontconfig把Arial替换成支持中文的字体。
解决办法 替换Arial的fontconfig配置是:
&amp;lt;match target=&amp;#34;pattern&amp;#34;&amp;gt; &amp;lt;test qual=&amp;#34;any&amp;#34; name=&amp;#34;family&amp;#34;&amp;gt; &amp;lt;string&amp;gt;Arial&amp;lt;/string&amp;gt; &amp;lt;/test&amp;gt; &amp;lt;edit name=&amp;#34;family&amp;#34; mode=&amp;#34;assign&amp;#34; binding=&amp;#34;same&amp;#34;&amp;gt; &amp;lt;string&amp;gt;Noto Sans S Chinese&amp;lt;/string&amp;gt; &amp;lt;/edit&amp;gt; &amp;lt;/match&amp;gt; 我用的是Noto Sans S Chinese，如果用文泉驿正黑就改成WenQuanYi Zen Hei。
怎么使这个配置生效？有两个方法。
环境变量 FONTCONFIG_FILE 这个方法需要一个为 Dota 2 单独准备的fontconfig_file，姑且命名为dota2-fontconfig.conf。
文件内容如下:
&amp;lt;?xml version=&amp;#34;1.0&amp;#34;?&amp;gt; &amp;lt;!DOCTYPE fontconfig SYSTEM &amp;#34;fonts.dtd&amp;#34;&amp;gt; &amp;lt;fontconfig&amp;gt; &amp;lt;include ignore_missing=&amp;#34;no&amp;#34;&amp;gt;fonts.conf&amp;lt;/include&amp;gt; &amp;lt;match target=&amp;#34;pattern&amp;#34;&amp;gt; &amp;lt;test qual=&amp;#34;any&amp;#34; name=&amp;#34;family&amp;#34;&amp;gt; &amp;lt;string&amp;gt;Arial&amp;lt;/string&amp;gt; &amp;lt;/test&amp;gt; &amp;lt;edit name=&amp;#34;family&amp;#34; mode=&amp;#34;assign&amp;#34; binding=&amp;#34;same&amp;#34;&amp;gt; &amp;lt;string&amp;gt;Noto Sans S Chinese&amp;lt;/string&amp;gt; &amp;lt;/edit&amp;gt; &amp;lt;/match&amp;gt; &amp;lt;/fontconfig&amp;gt; 然后用FONTCONFIG_FILE环境变量来传递。但是使用这个环境变量之后，fontconfig不会再加载/etc/fonts/fonts.</description></item><item><title>解决用 ldconfig 指定 libgl 库时 Steam 的异常</title><link>https://cubl.in/2015/01/ldconfig-and-steam-workaround/</link><pubDate>Wed, 28 Jan 2015 00:00:00 +0000</pubDate><guid>https://cubl.in/2015/01/ldconfig-and-steam-workaround/</guid><description>刚考完试，有点无聊，开 Steam 准备玩点游戏，结果发现之前的一个脚本不能用了。我的机器的情况是 Intel 集显 + NVIDIA 独显。两个显卡的切换一直是件很蛋疼的事情，optirun什么的性能实在太差，如果一直独显直出，耗电也是个大问题。这个学期初和 @hyrathb juju 一起研究了一下，用 ldconfig 尽可能减少切换显卡带来的麻烦(就是先关X, 然后跑个脚本开独显直出的X, 如果需要这个解决方案我可以单独po文).
Steam 的坑 Steam 为了Need to add /usr/lib32 to the library path to pick up libvdpau_nvidia.so on Ubuntu 12.04把/usr/lib32加进了LD_LIBRARY_PATH变量，结果虽然在 ldconfig 中本来是 NVIDIA 的 libgl 库优先，但是/usr/lib32里面默认 mesa 的 libgl 库的链接却被优先加载了。导致 Steam 启动时会报Not direct rendering之类的错误。
之前的解决办法 这个学期初是顺便解决了这个问题的，当时就是把 steam.sh 里面如下这行注释掉。
export LD_LIBRARY_PATH=&amp;#34;$LD_LIBRARY_PATH:/usr/lib32&amp;#34; 但是 Steam 会在启动时检查文件完整性，第一次检查是检查大小，所以把文件删掉一个字节就好了。不过要在启动 Steam 后换回原文件，因为 Steam 会第二次检查文件完整性，这次大概是检查哈希值。我是写了个脚本，准备两个文件，原文件和修改后的文件，cp 两次。不过最近升级后，第一次检查的好像也是哈希值了。检查的那些步骤估计都是写进二进制的，想绕过也比较麻烦，这脚本就没救了。
新发现 这次仔细读了一下 steam.sh, 这一块代码还是可以好好利用一下的:
# and launch steam STEAM_DEBUGGER=$DEBUGGER unset DEBUGGER # Don&amp;#39;t use debugger if Steam launches itself recursively if [ &amp;#34;$STEAM_DEBUGGER&amp;#34; == &amp;#34;gdb&amp;#34; ] || [ &amp;#34;$STEAM_DEBUGGER&amp;#34; == &amp;#34;cgdb&amp;#34; ]; then # Set the LD_PRELOAD varname in the debugger, and unset the global version.</description></item><item><title>Vim 删除成对的字符</title><link>https://cubl.in/2015/01/vimscript-delpair/</link><pubDate>Sun, 11 Jan 2015 00:00:00 +0000</pubDate><guid>https://cubl.in/2015/01/vimscript-delpair/</guid><description>今天为了偷懒又往 .vimrc 里面写了点东西，作用是在删除类似于()这种成对出现的字符对的前一个字符时同时删除后面那个&amp;hellip;
下面是具体内容:
inoremap &amp;lt;BS&amp;gt; &amp;lt;c-r&amp;gt;=DelPair()&amp;lt;CR&amp;gt;function DelPair() let currentline = getline(&amp;#39;.&amp;#39;) let prechar = currentline[col(&amp;#39;.&amp;#39;) - 2] let fochar = currentline[col(&amp;#39;.&amp;#39;) - 1] if (prechar == &amp;#39;(&amp;#39; &amp;amp;&amp;amp; fochar == &amp;#39;)&amp;#39;) \ || (prechar == &amp;#39;[&amp;#39; &amp;amp;&amp;amp; fochar == &amp;#39;]&amp;#39;) \ || (prechar == &amp;#39;&amp;lt;&amp;#39; &amp;amp;&amp;amp; fochar == &amp;#39;&amp;gt;&amp;#39;) \ || (prechar == &amp;#39;{&amp;#39; &amp;amp;&amp;amp; fochar == &amp;#39;}&amp;#39;) \ || (prechar == &amp;#39;&amp;#34;&amp;#39; &amp;amp;&amp;amp; fochar == &amp;#39;&amp;#34;&amp;#39;) \ || (prechar == &amp;#34;&amp;#39;&amp;#34; &amp;amp;&amp;amp; fochar == &amp;#34;&amp;#39;&amp;#34;) return &amp;#34;\&amp;lt;BS&amp;gt;\&amp;lt;Delete&amp;gt;&amp;#34; else return &amp;#34;\&amp;lt;BS&amp;gt;&amp;#34; endifendf</description></item><item><title>vpn-udp-libev 开发总结</title><link>https://cubl.in/2015/01/vpn-udp-libev-development-notes/</link><pubDate>Fri, 09 Jan 2015 00:00:00 +0000</pubDate><guid>https://cubl.in/2015/01/vpn-udp-libev-development-notes/</guid><description>最近又在看 UNIX 网络编程那本书，写了个 vpn 练手，代码和简单的介绍在 Github 上(好像效率还不错的样子)。这里照例做一下总结，便于以后查阅。
关于recvfrom() /* recvfrom() 的声明 */ ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen); 这个函数比较诡异的是它的最后一个参数addrlen.
If src_addr is not NULL, and the underlying protocol provides the source address of the message, that source address is placed in the buffer pointed to by src_addr. In this case, addrlen is a value-result argument. Before the call, it should be initialized to the size of the buffer associated with src_addr.</description></item><item><title>对 btrfs 的吐槽</title><link>https://cubl.in/2015/01/btrfs-sucks/</link><pubDate>Fri, 02 Jan 2015 00:00:00 +0000</pubDate><guid>https://cubl.in/2015/01/btrfs-sucks/</guid><description>刚把本来给/home和/var用的 btrfs 换回 ext4，po 一发记(tu)录(cao)一下。
一开始换 btrfs 呢，是感觉这个文件系统各种功能、各种酷炫啊，比如subvolume, snapshot什么的。我主要看中的其实是他的透明压缩，不仅节省硬盘空间，还能提高io的速率，这对我 5400转的 500G 硬盘还是有点作用的。不过当时年少不懂事，不知道有C这个文件属性，直接在/etc/fstab里用了全局压缩选项，结果导致虚拟机这种从单文件随机读取数据的场景速度慢到可怕。
有一个日常使用经常遇到的问题，不知道是不是和这个压缩的功能有关。跨文件系统(具体好像是btrfs&amp;lt;-&amp;gt;{fat32,ntfs})cp或者mv的时候，非常有可能会在读写进行到最后的时候 hang 住，怎么kill都终止不了 io 进程。这个时候如果ps看一下，会发现 io 进程陷入了disk_sleep的状态。这时候只好直接拔 USB 储存才行。
还有就是大家都在说的 btrfs 会丢失文件的问题。虽然我只遇到过一次，时间是在刚换 btrfs 之后没几天，有一个目录里面的有些文件莫名其妙就不见了，我当时很肯定是没有动这个目录的文件的，所以这件事就让我对 btrfs 的印象变得不是那么好了。
subvolume, snapshot虽然很酷，但是平时基本也没有不会用到太多。
subvolume可以实现一个分区挂载到多个目录，这样就省去了分区的麻烦。但是硬盘里面的东西多了以后，挂载一个subvolume的速度会变得非常慢。在我换回 ext4 之前，挂载一个subvolume的时间平均是 5s, 一次开机就让挂载卡去了 15s, 实在是非常不划算。而且这也不是没有替代方案。比如我现在就是把/var和/home放在一个分区，开机后挂载整个分区，然后用bind的方式挂载到根目录的具体位置上。
至于snapshot，用到它的就是我每两天一次的全盘备份和 docker 了。这还确实有点用处，不过用了半年，需要用到备份的时间也就一两次，docker 有没有 btrfs 其实也没什么区别。
所以呢，总的来说， btrfs 的问题还是有点多，一些有意思的功能日常也起不到必不可少的作用。想入 btrfs 坑的还是再观望一段时间吧，已经入 btrfs 坑的话我只能祝你好运了。</description></item><item><title>Paf 开发总结</title><link>https://cubl.in/2014/12/paf-develop-notes/</link><pubDate>Wed, 31 Dec 2014 00:00:00 +0000</pubDate><guid>https://cubl.in/2014/12/paf-develop-notes/</guid><description>Paf (Pipe as file) 并不是什么大项目，只是一时兴起为满足自己奇怪需求而开发的小工具。具体的介绍都摆在 Github 上了，这里就不赘述了。只是对开发过程中遇到的一些问题和技巧做一下总结。
EOF 的产生 pipe是有一定容量的1，这一部分就是内核维护的缓冲区。当pipe的读端试图对文件描述符执行read()系统调用的时候，内核会先检查缓冲区是否有数据，有则返回; 若没有，则根据读端文件描述符具体是否以阻塞标志打开，如阻塞，则阻塞至缓冲区有数据，或者当对端已经关闭文件描述符的时候，读端的read()调用会返回0, 这就是所谓的EOF。对pipe的写端执行close()并不会刷新pipe的缓冲区，而且读端也并不能立即察觉到写端已经关闭。这引发了一个问题，也是我在开发过程中碰到的一个很大的问题。如果写端在关闭后，在pipe的缓冲区还没被读端读取完的时候，重新打开并写入数据，这部分数据会写入原先的缓冲区并被读端继续读取。
FIFO 的正确使用姿势 上文提到的EOF并未被读端及时响应还会造成另一个问题。如果写端关闭后立即执行open()系统调用，这个函数不会阻塞，因为读端确实正处于打开的状态。另一方面，读端关闭后立即执行也不会阻塞。这对程序的逻辑造成了致命的影响，它让读端误以为第二次打开的是一个新的文件，同时让写端误以为读端已经在请求新文件的数据。
所以FIFO的正确使用姿势应该是在写端open()之后立即unlink()然后再mkfifo():
wfd = open(filename, O_WRONLY, NULL); unlink(filename); mkfifo(filename, FIFO_MODE); 虽然对FIFO进行了unlink(), 文件已经不存在，但是内核实际上还在维护读写两端的文件描述符和对应的缓冲区。而第二次mkfifo()即使创建的FIFO的名字是一样的，内核会为它维护另一套空间。这样的话，无论是读端还是写端，连续的两次open()都会阻塞。而且打开后缓冲区是空的。
二阶指针 二阶指针玩链表其实还是蛮有意思的嘛(虽然只是少定义一个中间变量)&amp;hellip;
stdin, stdout, stderr and tty /dev/{stdin,stdout,stderr}默认分别是/proc/self/fd/{0,1,2}的软链接，而/proc/self/fd/{0,1,2}默认都是pts或者tty的软链接，所以stdin, stdout, stderr默认就是终端设备。当stdin被 shell 用管道替换之后，可以用以下方式重新打开键盘输入(另外两个类似):
#include &amp;lt;unistd.h&amp;gt; /* for dup2(), close() and STDIN_FILENO */#include &amp;lt;fcntl.h&amp;gt; /* for open() and O_RDONLY */ int realstdin = open(&amp;#34;/dev/tty&amp;#34;, O_RDONLY); dup2(realstdin, STDIN_FILENO); close(realstdin); /dev/tty总是当前终端设备
More 想到什么我再更新吧。
pipe(7) - Linux man page&amp;#160;&amp;#x21a9;&amp;#xfe0e;</description></item><item><title>KDE窗口撕裂的解决办法</title><link>https://cubl.in/2014/03/kde%E7%AA%97%E5%8F%A3%E6%92%95%E8%A3%82%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</link><pubDate>Sat, 22 Mar 2014 00:00:00 +0000</pubDate><guid>https://cubl.in/2014/03/kde%E7%AA%97%E5%8F%A3%E6%92%95%E8%A3%82%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</guid><description>问题 从去年装archliux+kde开始就一直被kde窗口拖动时的残影和撕裂感折磨，之前观摩前辈 @撸神 的kde的时候发现了这个问题，他说这是kde的bug，所以这个问题就一直放着，直到昨天帮 @古真 装arch才开始注意。
最初以为是垂直同步没有开启，结果archwiki上提到intel集显是默认开启垂直同步的。尝试了一下，不论是开启还是关闭垂直同步实际上对这个问题都没有任何帮助。
解决办法 今天翻遍了archwiki，在Intel Graphics页面发现了解决办法，其中SNA是默认的模式。
播放视频时屏幕撕裂 若使用 SNA，将下列内容添加到 /etc/X11/xorg.conf.d/20-intel.conf 的 Device 段可杜绝屏幕撕裂问题。
Option &amp;ldquo;TearFree&amp;rdquo; &amp;ldquo;true&amp;rdquo;
如果20-intel.conf不存在可以创建一个。最简单的示例如下：
Section &amp;#34;Device&amp;#34; Identifier &amp;#34;Intel Graphics&amp;#34; Driver &amp;#34;intel&amp;#34; Option &amp;#34;TearFree&amp;#34; &amp;#34;true&amp;#34; EndSection 参考 1: Intel Graphics(Archwiki)</description></item><item><title>通过DNS隧道绕过portal认证</title><link>https://cubl.in/2014/02/%E9%80%9A%E8%BF%87dns%E9%9A%A7%E9%81%93%E7%BB%95%E8%BF%87portal%E8%AE%A4%E8%AF%81/</link><pubDate>Tue, 11 Feb 2014 00:00:00 +0000</pubDate><guid>https://cubl.in/2014/02/%E9%80%9A%E8%BF%87dns%E9%9A%A7%E9%81%93%E7%BB%95%E8%BF%87portal%E8%AE%A4%E8%AF%81/</guid><description>&lt;blockquote>
&lt;p>        Portal在英语中是入口的意思。Portal认证通常也称为Web认证，一般将Portal认证网站称为门户网站。未认证用户上网时，设备强制用户登录到特定站点，用户可以免费访问其中的服务。当用户需要使用互联网中的其它信息时，必须在门户网站进行认证，只有认证通过后才可以使用互联网资源。用户可以主动访问已知的Portal认证网站，输入用户名和密码进行认证，这种开始Portal认证的方式称作主动认证。反之，如果用户试图通过HTTP访问其他外网，将被强制访问Portal认证网站，从而开始Portal认证过程，这种方式称作强制认证。&lt;/p>
&lt;/blockquote>
&lt;p>比如说：华某科校园网(无线端), Chinanet, CMCC, China-Unicom&lt;/p>
&lt;p>（华某科校园网升级后，DNS隧道被一定程度限用，处于半残状态。基本无法使用。）&lt;/p>
&lt;p>portal认证不同于pppoe，它已经通过DHCP对Client分发IP，但是在完成认证前会强制重定向url到protal认证界面，只有登录后才能顺利的访问网络。不过portal认证&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->并没有阻止DNS查询&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->的请求，通过一定手段可以绕过portal认证，直接访问internet。我们需要的软件就是iodine&lt;/p>
&lt;blockquote>
&lt;p>iodine lets you tunnel IPv4 data through a DNS server. This can be usable in different situations where internet access is firewalled, but DNS queries are allowed.&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;/blockquote></description></item></channel></rss>