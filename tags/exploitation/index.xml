<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Exploitation on /home/cubl</title><link>/tags/exploitation/</link><description>Recent content in Exploitation on /home/cubl</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Mon, 23 Jul 2018 00:00:00 +0000</lastBuildDate><atom:link href="/tags/exploitation/index.xml" rel="self" type="application/rss+xml"/><item><title>Writeup: CTFZone 2018 Quals</title><link>/2018/07/writeup-ctfzone/</link><pubDate>Mon, 23 Jul 2018 00:00:00 +0000</pubDate><guid>/2018/07/writeup-ctfzone/</guid><description>两道PWN题, 一个easypwn_strings, 一个Mobile Bank.
easypwn_strings 问题 You can try to use very interesting and strange string functions ;) Good luck. nc pwn-03.v7frkwrfyhsjtbpfcppnu.ctfz.one 1234 And yes, there is no binary here
这是一道盲pwn类型的题，没有提供二进制(名义上的)。
nc连上之后回显：
Let's choose string operation! 1. StrLen 2. SubStrRemove 3. StrRemoveLastSymbols 第一个选项：输入一个字符串，回显字符串长度。
You choise - 1 Use str good choise 123 Result: 3 第二个选项显示未实现。
第三个选项：输入一个字符串，和一个数字，服务端移除末尾指定长度的字符串后打印出来。
You choise - 3 Use str int good choise Set string: 1234567 Set number: 3 Delete 3 ending symbols Result: 1234 思路 既然是无ELF文件的盲pwn，那只能摸着石头过河。做题时有以下几个尝试：</description></item><item><title>Writeup: ZCTF</title><link>/2016/01/writeup-zctf/</link><pubDate>Sun, 24 Jan 2016 00:00:00 +0000</pubDate><guid>/2016/01/writeup-zctf/</guid><description>2016 年第一篇 blog!
这次只做出两道 pwn, 好忧伤&amp;hellip;
guess 在最近的 32c3ctf 中出现过一道类似的 readme1. 就是把argv[1]改成目的字符串位置，可以在 libc 打出错误信息的时候，被当作文件名打印出来。
Gist: cubarco/cbbd4ab5462c2f0f287b
note1 这题的 note 是以链表形式储存的，堆溢出（edit 存在溢出漏洞）之后可以覆盖地址更改链表结构。我的 exp 思路就是先把一个 note 指向setvbuf()的 got, 然后用 show 把地址 leak 出来，这样可以 offset 到system(). 然后再将另一个 note 地址改到strcmp()的 got, 通过 edit 把内容改成system()的地址。最后调用strcmp(), title 填/bin/sh就可以了。
Gist: cubarco/30a44a61252f448964c4
note2 这题在赛时没找到漏洞，赛后看了 FlappyPig 的 Writeup2, 只是简单的 fastbin, 感觉好可惜&amp;hellip; 360 安全播报给的代码没缩进根本不能看，自己重新写了个。
Gist: cubarco/9752fbbe78a071b04b37
note3 这题同样是没有在赛时做出来，但是与 note2 相反，这题我是找到了两个可以利用的漏洞的(一个是 integer overflow, 另一个是可以增加第八个 note), 但是不知道如何利用。我在比赛的时候一直想着怎么 fastbin, 因为我觉得 unlink 这么古老的 exp 肯定已经不能用了&amp;hellip; 没想到这题的环境刚好适合 unlink, 有点可惜。赛后看了 FlappyPig 的 Writeup2, 自己重新写了个 exp, 也算是复习一下 unlink.</description></item><item><title>Writeup: 32c3ctf</title><link>/2015/12/writeup-32c3ctf/</link><pubDate>Wed, 30 Dec 2015 00:00:00 +0000</pubDate><guid>/2015/12/writeup-32c3ctf/</guid><description>forth forth 直接能跑system1。
1 S&amp;#34; sh&amp;#34; system gurke pickle 在 unpickle 的时候会执行对象的 __reduce__ 方法2。用 eval 把 __main__.flag.flag 打进 stderr 就行了。
Gist: cubarco/e46eb03e1cd06046d130
teufel 这题的 bin 不大，里面的 gadgets 很少，但是给了 libc. 思路就是先 leak 出保存在栈中的 rbp, 然后 offset 到 system。
这个 offset 要先在本机确定后三位(16 进制), 然后跑个脚本，用 0x1000 的步长去爆破服务器上的 offset. 我的办法是先找__stack_chk_fail, 原因是这个函数不需要参数就能输出。
offset.py Gist: cubarco/569fd814a29d8ef988e1
exp.py Gist: cubarco/569fd814a29d8ef988e1
吐槽 readme 的 flag 居然是文件名&amp;hellip; 不过LIBC_FATAL_STDERR_这个环境变量确实是以前没见过的。
update 2016-01-24: 关于 readme 这道题，之前以为 flag 是文件名，做 ZCTF 的 guess 时3，回来看才发现原来是把argv[1]改掉了，蛮有意思。</description></item><item><title>Writeup-Pwnable: unexploitable</title><link>/2015/12/writeup-pwnable-unexploitable/</link><pubDate>Wed, 23 Dec 2015 00:00:00 +0000</pubDate><guid>/2015/12/writeup-pwnable-unexploitable/</guid><description>ROP 这题主要就是在 0x400560 藏了一个0F 0A的 opcode, 对应的 x64 指令是syscall, 找到这个就好办了。
然后构造 ROP, 一开始找不到控制 rax 的 gadgets, 搜了一下发现可以利用read()的返回值。具体的构造就是时间问题了，x64 的 ROP 可以看这篇文章1。
exp-rop.py Gist: cubarco/23b04edc7e79b1c71547
SROP 结果 flag 里提到 SROP 的解法，我就又写了个 SROP. 简单的 SROP 介绍可以看这篇文章2。
exp-srop.py Gist: cubarco/23b04edc7e79b1c71547
一步一步学ROP之linux_x64篇&amp;#160;&amp;#x21a9;&amp;#xfe0e;
Sigreturn Oriented Programming (SROP) Attack攻击原理&amp;#160;&amp;#x21a9;&amp;#xfe0e;</description></item><item><title>Writeup-Pwnable: syscall</title><link>/2015/12/writeup-pwnable-syscall/</link><pubDate>Wed, 16 Dec 2015 00:00:00 +0000</pubDate><guid>/2015/12/writeup-pwnable-syscall/</guid><description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 // adding a new system call : sys_upper #include &amp;lt;linux/module.h&amp;gt;#include &amp;lt;linux/kernel.h&amp;gt;#include &amp;lt;linux/slab.h&amp;gt;#include &amp;lt;linux/vmalloc.h&amp;gt;#include &amp;lt;linux/mm.h&amp;gt;#include &amp;lt;asm/unistd.h&amp;gt;#include &amp;lt;asm/page.h&amp;gt;#include &amp;lt;linux/syscalls.h&amp;gt; #define SYS_CALL_TABLE 0x8000e348 // manually configure this address!</description></item><item><title>Writeup-Pwnable: tiny &amp; tiny_easy</title><link>/2015/12/writeup-pwnable-tiny-and-tiny-easy/</link><pubDate>Fri, 11 Dec 2015 00:00:00 +0000</pubDate><guid>/2015/12/writeup-pwnable-tiny-and-tiny-easy/</guid><description>tiny_easy 1. Brute force 这题的 bin 拿到之后开 gdb 看了一下 mapping, 发现 stack 是可执行的(如果 ELF 没有 GNU_STACK 这个 header, 则默认 stack 可执行1)。所以思路很明显了。
看一下反汇编:
1 2 3 4 8048054: 58 pop %eax 8048055: 5a pop %edx 8048056: 8b12 mov (%edx),%edx 8048058: ffd2 call *%edx 然后用 gdb 断在 entry point, 观察一下栈:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 $ gdb tiny_easy (gdb) b *0x8048054 Breakpoint 1 at 0x8048054 (gdb) r Starting program: /home/tiny_easy/tiny_easy Breakpoint 1, 0x08048054 in ?</description></item><item><title>Writeup-Seccon CTF: FSB:TreeWalker</title><link>/2015/12/seccon-ctf-writeup-fsb-treewalker/</link><pubDate>Mon, 07 Dec 2015 00:00:00 +0000</pubDate><guid>/2015/12/seccon-ctf-writeup-fsb-treewalker/</guid><description>printf() 因为这题直接把 FSB 写在题名里，我一拿到题就直接跑去找能利用 FSB 的点了。
利用点在这里：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 400881: 0f 1f 80 00 00 00 00 nopl 0x0(%rax) 400888: 4c 8b 05 f9 09 20 00 mov 0x2009f9(%rip),%r8 # 601288 &amp;lt;stdin@@GLIBC_2.2.5&amp;gt; 40088f: 48 8d 7c 24 50 lea 0x50(%rsp),%rdi 400894: ba 01 00 00 00 mov $0x1,%edx 400899: be 00 10 00 00 mov $0x1000,%esi 40089e: e8 fd fe ff ff callq 4007a0 &amp;lt;__fread_chk@plt&amp;gt; 4008a3: 48 39 44 24 08 cmp %rax,0x8(%rsp) 4008a8: 0f 85 81 00 00 00 jne 40092f &amp;lt;main+0x14f&amp;gt; 4008ae: 48 8d 74 24 50 lea 0x50(%rsp),%rsi 4008b3: bf 01 00 00 00 mov $0x1,%edi 4008b8: 31 c0 xor %eax,%eax 4008ba: e8 d1 fe ff ff callq 400790 &amp;lt;__printf_chk@plt&amp;gt; 4008bf: 48 8b 0d c2 09 20 00 mov 0x2009c2(%rip),%rcx # 601288 &amp;lt;stdin@@GLIBC_2.</description></item><item><title>Writeup-9447 CTF: calcpop-reloaded</title><link>/2015/12/9477-calcpop-reloaded-writeup/</link><pubDate>Fri, 04 Dec 2015 00:00:00 +0000</pubDate><guid>/2015/12/9477-calcpop-reloaded-writeup/</guid><description>从这一题开始，9447 加上了 POW, 其实只要爆破就可以，这里就不放脚本了。（关于 POW, 有个叫 hashcash 的东西，挺有意思的）
这道题我没有在比赛期间做出来。当时完全没有逆向 load address 未知的二进制的经验，什么都干不了。后来简单看了别人的 writeup，在只知道逆向方法的情况下重新做出了这题。前后大概还是花了七八小时（我好渣&amp;hellip;），硬着头皮写篇 writeup 记录一下。
Load Address 找 load address 的过程大概是先用 radare 打开，然后翻反汇编代码，可以找到mov eax, 0x1007a7这类代码，大概可以猜出 load address 在 0x100000.
用 IDA 打开，填好 load offset, 开始调试。可以猜出 main 函数(?)的位置大概在 0x1008bc.
Overflow 接下来找溢出点。可以看到 0x001008EE 处调用了输入函数，分配栈空间是 0x98, 但是传递了一个大概是 size 的参数，值为 0x100. 存在溢出。
这题和 calcpop 有一点不同的是，calcpop 中输入 exit 会直接退出 main 函数，这题输入 exit 会调用shutdown()之类的函数，没细看，效果就是不会再有输出了。这道题退出 main 函数的方法是，正确输入，让计算结果为 201527, 程序会输出彩蛋信息，然后退出 main 函数。
接下来就是怎么溢出了，先看 main 函数入口和出口处的栈变化：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 ; entry: lea ecx, [esp-4] and esp, 0FFFFFFF0h push dword ptr [ecx-4] push ebp mov ebp, esp push edi push esi push ebx push ecx ; exit: lea esp, [ebp-10h] xor eax, eax pop ecx pop ebx pop esi pop edi pop ebp lea esp, [ecx-4] retn 溢出到保存 ecx 的位置，使 ecx - 4 指向存有 shellcode 地址的栈位置，然后 ret 就能跳转到 shellcode.</description></item><item><title>Writeup-9447 CTF: calcpop</title><link>/2015/11/9477-calcpop-writeup/</link><pubDate>Mon, 30 Nov 2015 00:00:00 +0000</pubDate><guid>/2015/11/9477-calcpop-writeup/</guid><description>先看反汇编代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 ... 8048460: 55 push %ebp 8048461: 89 e5 mov %esp,%ebp 8048463: 57 push %edi 8048464: 56 push %esi 8048465: be 00 01 00 00 mov $0x100,%esi 804846a: 53 push %ebx 804846b: 83 e4 f0 and $0xfffffff0,%esp 804846e: 81 ec 90 00 00 00 sub $0x90,%esp 8048474: a1 60 a0 04 08 mov 0x804a060,%eax 8048479: c7 44 24 0c 00 00 00 movl $0x0,0xc(%esp) 8048480: 00 8048481: 8d 5c 24 10 lea 0x10(%esp),%ebx 8048485: c7 44 24 08 02 00 00 movl $0x2,0x8(%esp) 804848c: 00 804848d: 89 df mov %ebx,%edi 804848f: c7 44 24 04 00 00 00 movl $0x0,0x4(%esp) 8048496: 00 8048497: 89 04 24 mov %eax,(%esp) 804849a: e8 a1 ff ff ff call 8048440 &amp;lt;setvbuf@plt&amp;gt; 804849f: c7 04 24 10 88 04 08 movl $0x8048810,(%esp) 80484a6: e8 55 ff ff ff call 8048400 &amp;lt;puts@plt&amp;gt; 80484ab: eb 29 jmp 80484d6 &amp;lt;main+0x76&amp;gt; 80484ad: 8d 76 00 lea 0x0(%esi),%esi 80484b0: a1 40 a0 04 08 mov 0x804a040,%eax 80484b5: 89 04 24 mov %eax,(%esp) 80484b8: e8 33 ff ff ff call 80483f0 &amp;lt;_IO_getc@plt&amp;gt; 80484bd: 85 c0 test %eax,%eax 80484bf: 0f 88 e3 00 00 00 js 80485a8 &amp;lt;main+0x148&amp;gt; 80484c5: 88 07 mov %al,(%edi) 80484c7: 83 ee 01 sub $0x1,%esi 80484ca: 83 c7 01 add $0x1,%edi 80484cd: 83 f8 0a cmp $0xa,%eax 80484d0: 0f 84 ca 00 00 00 je 80485a0 &amp;lt;main+0x140&amp;gt; 80484d6: 83 fe 01 cmp $0x1,%esi 80484d9: 77 d5 ja 80484b0 &amp;lt;main+0x50&amp;gt; 80484db: 85 f6 test %esi,%esi 80484dd: 0f 85 bd 00 00 00 jne 80485a0 &amp;lt;main+0x140&amp;gt; .</description></item></channel></rss>