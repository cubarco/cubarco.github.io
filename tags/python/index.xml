<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Python on /home/cubl</title><link>/tags/python/</link><description>Recent content in Python on /home/cubl</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Thu, 15 Jan 2015 00:00:00 +0000</lastBuildDate><atom:link href="/tags/python/index.xml" rel="self" type="application/rss+xml"/><item><title>在社交平台上发布匹配一定规则的 Github commit message</title><link>/2015/01/post-github-commits-to-social-platforms/</link><pubDate>Thu, 15 Jan 2015 00:00:00 +0000</pubDate><guid>/2015/01/post-github-commits-to-social-platforms/</guid><description>之前看到了 @fqj1994 juju 的这篇 blog: 用 Google App Script 實現博客更新時自動在社交網絡上發狀態分享, 也感觉自己的 blog 根本没人访问，需要一个类似的东西。因为我的 blog 是用的 jekyll, 挂在 Github 上的，Github 又提供了一个叫 Webhook 的东西，就准备自己实现一种更加优雅的方式。
项目放在 Github 上，遵循 GPLv2 协议。整个流程很简单，就是接受 Webhook 发来的 json, 然后从中提取 commits message, 用一定的正则表达式取出标题，之后再发往各个社交平台。
昨天实现了 twitter 的部分(twitter 可以拿到不会过期的 access token)，看了下 OAuth 感觉要维护那些 token 的状态好麻烦，懒得弄&amp;hellip; 我正在用的主要就是 twitter, Google+, 和 Facebook. Google+ 据说没给发 post 的 api, 所以作罢。接下来尽可能支持 Facebook.
如果腳本正常的話，理論上這則文章會很快被發佈到我常用的社交網絡。
嗯，就是这样。
Update 2015-01-15: 这个 blog 发出去之后发现 log 报错了(UnicodeEncodeError)，但是没时间修了(出去玩了)。晚上回来处理完各种事情之后才开始修。发现是 urllib.urlencode() 不支持 unicode, fix 已经推到 Github 上了&amp;hellip; 感觉 python 还是学的不好啊。其实我一开始学 python 就是随手写个后台，没准备深入。现在又发觉 python 挺好用的，但是不知道怎么深入，有心无力的感觉哎。</description></item><item><title>Writeup-Training: Warchall - 7 Tropical Fruits</title><link>/2014/05/wechall-tropic-writeup/</link><pubDate>Wed, 14 May 2014 00:00:00 +0000</pubDate><guid>/2014/05/wechall-tropic-writeup/</guid><description>Wechall的tropic这道题真是撸得我考试周复(yu)习(xi)都没心思了，花了两天半终于搞定了，才63人做出来的题目居然是training！！！
做这题的时候也是我第一次写shellcode，不过这道题难点不在于shellcode怎么写，而在于坑爹的ASLR。不说stack的地址一直在变，居然连linux-gate.so都在变！
一开始查了好久，发现个思路叫ret2libc，然后我gdb了一下，发现system()的地址虽然是随机的，但是有6位是不变的。然后我就撸啊撸，撸了个shell脚本，速度不错，居然半分钟之内就能把system(“sh”)跑出来。看到”sh-4.2$”的时候我那叫一个激动啊。坑爹的是system()这货执行的时候居然会丢掉suid的权限(man system#NOTES)。
所以忙活了一天，我的成果就是，在一个shell下面，再开一个shell……
然后第二天我不甘心啊，就找啊找找啊找，找到了exec函数族。
#include &amp;lt;unistd.h&amp;gt;extern char **environ; int execl(const char *path, const char *arg, ...); int execlp(const char *file, const char *arg, ...); int execle(const char *path, const char *arg, ..., char * const envp[]); int execv(const char *path, char *const argv[]); int execvp(const char *file, char *const argv[]); int execve(const char *path, char *const argv[], char *const envp[]); //其中只有execve是真正意义上的系统调用，其它都是在此基础上经过包装的库函数。 这货厉害，suid会传递下去，但是悲催的是每个函数的参数不止一个，而且大多都要求最后一个参数为NULL(直接无视)，但是execv之类的函数又不方便构造后面的那些二阶指针，所以我昨天就是在满屏的Segmentation Fault中度过的，偶尔出现的Invalid Instruction能让人高兴好一阵。
第二天无果，不过我cat了一下compile7.sh，发现了好玩的东西
#!/bin/bash gcc -fno-stack-protector -z execstack level7.</description></item></channel></rss>