<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>C on /home/cubl</title><link>/tags/c/</link><description>Recent content in C on /home/cubl</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sat, 02 May 2015 00:00:00 +0000</lastBuildDate><atom:link href="/tags/c/index.xml" rel="self" type="application/rss+xml"/><item><title>C Programming Tricks</title><link>/2015/05/02/c-programming-tricks/</link><pubDate>Sat, 02 May 2015 00:00:00 +0000</pubDate><guid>/2015/05/02/c-programming-tricks/</guid><description>这个 Note 用来记录各处收集的 C 编程 tricks. 看到有意思的就会摘一下，来源各异。
Anonymous arrays C99 offers some really cool stuff using anonymous arrays:
Removing pointless variables 1 2 3 4 int yes=1; setsockopt(yourSocket, SOL_SOCKET, SO_REUSEADDR, &amp;amp;yes, sizeof(int)); /* becomes: */ setsockopt(yourSocket, SOL_SOCKET, SO_REUSEADDR, (int[]){1}, sizeof(int)); Passing a Variable Amount of Arguments 1 2 3 4 5 6 7 8 Void func(type* values) { while(*values) { x = *values++; /* do whatever with x */ } } func((type[]){val1,val2,val3,val4,0}); Static linked lists 1 2 3 4 5 6 7 8 9 10 int main() { struct llist { int a; struct llist* next;}; #define cons(x,y) (struct llist[]){ {x,y} } struct llist *list=cons(1, cons(2, cons(3, cons(4, NULL)))); struct llist *p = list; while(p !</description></item><item><title>[转] C中的可变参数研究</title><link>/2014/02/25/%E8%BD%AC-c%E4%B8%AD%E7%9A%84%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E7%A0%94%E7%A9%B6/</link><pubDate>Tue, 25 Feb 2014 00:00:00 +0000</pubDate><guid>/2014/02/25/%E8%BD%AC-c%E4%B8%AD%E7%9A%84%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E7%A0%94%E7%A9%B6/</guid><description>初学C，感觉可变参数挺好玩的，转载一发做个mark。本想注明来源，发现来源也是转载的，找不到根源，就不贴链接了。
一. 何谓可变参数 1 int printf(const char* format, ...); 这是使用过C语言的人所再熟悉不过的printf函数原型，它的参数中就有固定参数format和可变参数（用”…”表示）. 而我们又可以用各种方式来调用printf,如:
1 2 3 printf(&amp;#34;%d&amp;#34;,value); printf(&amp;#34;%s&amp;#34;,str); printf(&amp;#34;the number is %d,string is: %s&amp;#34;, value, str); 二. 实现原理 C语言用宏来处理这些可变参数。这些宏看起来很复杂，其实原理挺简单，就是根据参数入栈的特点从最靠近第一个可变参数的固定参数开始，依次获取每个可变参数的地址。下面我们来分析这些宏。在VC中的stdarg.h头文件中，针对不同平台有不同的宏定义，我们选取X86平台下的宏定义：
1 2 3 4 5 6 7 8 9 10 11 12 typedef char *va_list; /*把va_list被定义成char*，这是因为在我们目前所用的PC机上，字符指针类型可以用来存储内存单元地址。而在有的机器上va_list是被定义成void*的*/ #define _INTSIZEOF(n) ((sizeof(n) + sizeof(int) - 1) &amp;amp; ~(sizeof(int) - 1)) /*_INTSIZEOF(n)宏是为了考虑那些内存地址需要对齐的系统，从宏的名字来应该是跟sizeof(int)对齐。一般的sizeof(int)=4，也就是参数在内存中的地址都为4的倍数。比如，如果sizeof(n)在1－4之间，那么_INTSIZEOF(n)＝4；如果sizeof(n)在5－8之间，那么_INTSIZEOF(n)=8。*/ #define va_start(ap,v)(ap = (va_list)&amp;amp;v + _INTSIZEOF(v)) /*va_start的定义为 &amp;amp;v+_INTSIZEOF(v), 这里&amp;amp;v是最后一个固定参数的起始地址，再加上其实际占用大小后，就得到了第一个可变参数的起始内存地址。所以我们运行va_start(ap, v)以后,ap指向第一个可变参数在的内存地址*/ #define va_arg(ap,t) (*(t*)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t))) /*这个宏做了两个事情， ①用用户输入的类型名对参数地址进行强制类型转换，得到用户所需要的值 ②计算出本参数的实际大小，将指针调到本参数的结尾，也就是下一个参数的首地址，以便后续处理。*/ #define va_end(ap) (ap = (va_list)0) /*x86平台定义为ap=(char*)0;使ap不再指向堆栈,而是跟NULL一样.</description></item></channel></rss>