<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>ROP on /home/cubl</title><link>/tags/rop/</link><description>Recent content in ROP on /home/cubl</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Wed, 23 Dec 2015 00:00:00 +0000</lastBuildDate><atom:link href="/tags/rop/index.xml" rel="self" type="application/rss+xml"/><item><title>Writeup-Pwnable: unexploitable</title><link>/2015/12/writeup-pwnable-unexploitable/</link><pubDate>Wed, 23 Dec 2015 00:00:00 +0000</pubDate><guid>/2015/12/writeup-pwnable-unexploitable/</guid><description>ROP 这题主要就是在 0x400560 藏了一个0F 0A的 opcode, 对应的 x64 指令是syscall, 找到这个就好办了。
然后构造 ROP, 一开始找不到控制 rax 的 gadgets, 搜了一下发现可以利用read()的返回值。具体的构造就是时间问题了，x64 的 ROP 可以看这篇文章1。
exp-rop.py Gist: cubarco/23b04edc7e79b1c71547
SROP 结果 flag 里提到 SROP 的解法，我就又写了个 SROP. 简单的 SROP 介绍可以看这篇文章2。
exp-srop.py Gist: cubarco/23b04edc7e79b1c71547
一步一步学ROP之linux_x64篇&amp;#160;&amp;#x21a9;&amp;#xfe0e;
Sigreturn Oriented Programming (SROP) Attack攻击原理&amp;#160;&amp;#x21a9;&amp;#xfe0e;</description></item><item><title>Writeup-Pwnable: tiny &amp; tiny_easy</title><link>/2015/12/writeup-pwnable-tiny-and-tiny-easy/</link><pubDate>Fri, 11 Dec 2015 00:00:00 +0000</pubDate><guid>/2015/12/writeup-pwnable-tiny-and-tiny-easy/</guid><description>tiny_easy 1. Brute force 这题的 bin 拿到之后开 gdb 看了一下 mapping, 发现 stack 是可执行的(如果 ELF 没有 GNU_STACK 这个 header, 则默认 stack 可执行1)。所以思路很明显了。
看一下反汇编:
8048054: 58 pop %eax 8048055: 5a pop %edx 8048056: 8b12 mov (%edx),%edx 8048058: ffd2 call *%edx 然后用 gdb 断在 entry point, 观察一下栈:
$ gdb tiny_easy (gdb) b *0x8048054 Breakpoint 1 at 0x8048054 (gdb) r Starting program: /home/tiny_easy/tiny_easy Breakpoint 1, 0x08048054 in ?? () (gdb) x/32wx $esp 0xffd82d70: 0x00000001 0xffd84df5 0x00000000 0xffd84e0f 0xffd82d80: 0xffd84e1f 0xffd84e33 0xffd84e54 0xffd84e68 0xffd82d90: 0xffd84e77 0xffd84e83 0xffd84ed0 0xffd84ee9 0xffd82da0: 0xffd84ef8 0xffd84f0c 0xffd84f1d 0xffd84f63 0xffd82db0: 0xffd84f6c 0xffd84f81 0xffd84f89 0xffd84f99 0xffd82dc0: 0xffd84fab 0x00000000 0x00000020 0xf776bb50 0xffd82dd0: 0x00000021 0xf776b000 0x00000010 0x0fabfbff 0xffd82de0: 0x00000006 0x00001000 0x00000011 0x00000064 发现 $esp 位置是命令行参数的个数(即 argc)，后面借着的都是 argv[i], 以 NULL 结尾，再之后都是环境变量(即 envp)。</description></item></channel></rss>