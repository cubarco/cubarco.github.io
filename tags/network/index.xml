<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Network on /home/cubl</title><link>/tags/network/</link><description>Recent content in Network on /home/cubl</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Fri, 09 Jan 2015 00:00:00 +0000</lastBuildDate><atom:link href="/tags/network/index.xml" rel="self" type="application/rss+xml"/><item><title>vpn-udp-libev 开发总结</title><link>/2015/01/vpn-udp-libev-%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/</link><pubDate>Fri, 09 Jan 2015 00:00:00 +0000</pubDate><guid>/2015/01/vpn-udp-libev-%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/</guid><description>最近又在看 UNIX 网络编程那本书，写了个 vpn 练手，代码和简单的介绍在 Github 上(好像效率还不错的样子)。这里照例做一下总结，便于以后查阅。
关于recvfrom() 1 2 3 /* recvfrom() 的声明 */ ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen); 这个函数比较诡异的是它的最后一个参数addrlen.
1 2 3 4 5 6 7 8 If src_addr is not NULL, and the underlying protocol provides the source address of the message, that source address is placed in the buffer pointed to by src_addr. In this case, addrlen is a value-result argument.</description></item></channel></rss>